###盒模型 [Try It](./demo/boxSizing.html)
* 什么是盒模型？  
盒模型又称框模型，包含了元素的内容（content）、内边距（padding）、边框（border）、外边框（margin）几个要素。  
* content-box ==> W3C标准盒模型
> width和height不包含border和padding
* border-box ==> IE盒模型
> width和height包含border和padding

通过css3的属性box-sizing: content-box|border-box分别设置盒模型为标准盒模型和IE盒模型  

###CSS选择器  
选择器可以被分为以下类别：  
- 简单选择器：通过元素类型、class或id匹配一个或多个元素。
    1. 类型选择器：此选择器是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。  
    2. 类选择器：由一个点'.'以及类后面的类名组成。类名是在HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名（以空格分开多个类名的形式书写）。  
    3. ID选择器：ID选择器由哈希符号(#)，后面是给定元素的ID名称。任何元素都可以使用id属性设置唯一的ID名称。这是选择单个元素的最有效的方式。 
        重要提示：一个ID名称必须在文件中是唯一的。关于重复ID的行为是不可预测的。比如在一个些浏览器只计算第一个实例，其余的将被忽略。   
    4. 通用选择器：通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。由于给每个元素应用同样的规则几乎没有什么实际的价值，更常见的做法是与其他选择器结合使用。  
        重要提示：使用通用选择时小心。因为它适用于所有的元素，在大型网页利用它可以对性能有明显的影响：网页可以显示比预期要慢。
- 属性选择器：通过属性和属性值匹配一个或多个元素。通用语法由方括号([])组成，其中包含属性名称，后跟可选条件以匹配属性的值。  
    1. 存在和值属性选择器：尝试匹配精确的属性值  
        a. [attr]: 该选择器选择包含attr属性的所有元素，不论attr的值为何。  
        b. [attr=val]: 该选择器仅选择attr属性被赋值为val的所有元素。
        c. [attr~=val]: 该选择器仅选择attr属性的值(以空格间隔出多个值)中有包含val值的所有元素，比如位于被空格分隔的多个类中的一个类。
    2. 子串值属性选择器：这种情况的属性选择器也被称为'伪正则选择器'，因为它提供类似正则的灵活匹配方式，但并不是正则表达式。
        a. [attr|=val]: 选择attr属性的值以val(包括val)或val-开头的元素(-用来处理语言编码)
        b. [attr^=val]: 选择attr属性的值以val开头(包括val)的元素
        c. [attr$=val]: 选择attr属性的值以val结尾(包括val)的元素
        d. [attr*=val]: 选择attr属性的值中包含字符串val的元素
- 伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。 
    1. 伪类：是一个以冒号(:)作为前缀的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以在元素的选择器后面加上对应的伪类。
    :active
    :any
    :checked
    :default
    :dir()
    :disabled
    :empty
    :enabled
    :first
    :first-child
    :first-of-type
    :fullscreen
    :focus
    :hover
    :indeterminate
    :in-range
    :invalid
    :lang()
    :last-child
    :last-of-type
    :left
    :link
    :not()
    :nth-child()
    :nth-last-child()
    :nth-last-of-type()
    :nth-of-type()
    :only-child
    :only-of-type
    :optional
    :out-of-range
    :read-only
    :read-write
    :required
    :right
    :root
    :scope
    :target
    :valid
    :visited
    2. 伪元素：伪元素的前缀是两个冒号(::)，同样是添加到选择器后面达到指定某个元素的某个部分 
    ::after
    ::before
    ::first-letter
    ::first-line
    ::selection
    ::backdrop
- 组合器：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。 
    1. 后代选择器：空格键 允许选择嵌套在另一个元素中的某一个元素。
    2. 子选择器：> 允许选择一个元素，该元素是另一个元素的直接子元素。
    3. 相邻兄弟选择器：+ 允许选一个元素，该元素是另一个元素的直接兄弟元素。（在旁边，在层次结构的同一层）
    4. 通用兄弟选择器：~ 允许选择其他元素的兄弟元素。（在层次结构中的相同级别，但不一定在旁边）
    注意：相邻兄弟选择器和通用兄弟选择器只会向后选择，DOM结构靠前的兄弟元素不在选择范围内
- 多用选择器：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个css规则下面，以将一组声明应用于由这些选择器选择的所有元素。  

###BFC [Try It](./demo/BFC.html) [Detail](https://juejin.im/post/59b73d5bf265da064618731d)
块级格式化上下文 是一个独立的渲染区域 让处于BFC内部的元素与外部的元素互相隔离 使内外元素的定位不会相互影响
* 触发条件
    * body根元素
    * 绝对定位元素：position: absolute/fixed
    * display 为 inline-block、table-cells、flex
    * 浮动元素：float除none以外的值
    * overflow 除了 visible 以外的值 (hidden、auto、scroll)
* 规则
    * 属于同一个BFC的两个相邻Box垂直排列
    * 属于同一个BFC的两个相邻Box的margin会发生重叠
    * BFC中子元素的margin box的左边 与包含块（BFC）border box的左边相接触（子元素absolute除外）
    * BFC的区域不会与float的元素区域重叠
    * 计算BFC的高度时 浮动子元素也参与计算
    * 文字层不会被浮动层覆盖 环绕于周围
* 应用
    * 阻止margin重叠
    * 可以包含浮动元素----清除内部浮动（清除浮动的原理是两个div都位于同一个BFC区域之中）
    * 自适应两栏布局
    * 可以阻止元素被浮动元素覆盖
    
###position
1. 静态定位（static）
静态定位是默认行为，意味着将元素放入它在文档布局流中的正常位置。
2. 相对定位（relative）
与静态定位相似，占据在正常的文档流中，除了仍然可以修改它的最终位置，包括让它与页面上的其他元素重叠（需要使用top,bottom,left,right属性，指定要将定位元素移动到的位置）。
3. 绝对定位（absolute）
绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层，独立于一切。这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能。
（top,bottom,left,right属性指定元素应距离每个包含元素的边的距离，而不是指定元素应该移入的方向，margin仍然会影响定位的元素）。
    - 定位上下文
    如果所有的父元素的position属性都是static，那么定位元素会被包含在初始块容器中。
    这个初始块容器有着和浏览器视口一样的尺寸，并且<html>元素也被包含在这个容器里面。
    简单来说，绝对定位元素会被放在<html>元素的外面，并且根据浏览器视口来定位。
    我们可以改变定位上下文 —— 绝对定位的元素的相对位置元素。
    通过设置其中一个父元素的定位属性 —— 也就是包含绝对定位元素的那个元素（如果要设置绝对定位元素的相对元素，那么这个元素一定要包含绝对定位元素）
4. 固定定位（fixed）
绝对定位的工作方式完全相同，只有一个主要区别：绝对定位固定元素是相对于 <html> 元素或其最近的定位祖先，而固定定位固定元素则是相对于浏览器视口本身。
5. 粘性定位（sticky）
基本上是相对位置和固定位置的混合体，它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点（例如，从视口顶部起1​​0像素）为止，此后它就变得固定了。
例如，它可用于使导航栏随页面滚动直到特定点，然后粘贴在页面顶部。

###flex
设置flex布局后，子元素的float、clear和vertical-align属性将失效。
采用flex布局的元素，称为flex容器。他的所有子元素自动成为容器成员，称为flex项目。
容器默认存在主轴和与主轴垂直的交叉轴，主轴/交叉轴开始的位置叫做起始线，结束位置叫终止线。
- 容器的属性
    * flex-direction: row | row-reverse | column | column-reverse
        决定主轴的方向
    * flex-wrap: nowrap | wrap | wrap-reverse
        默认情况下，项目都排在一条轴线上。定义如果一条轴线排不下，如何换行
    * flex-flow
        是flex-direction和flex-wrap的简写形式
    * justify-content: flex-start | flex-end | center | space-between | space-around
        定义了项目在主轴上的对齐方式
    * align-items: flex-start | flex-end | center | baseline | stretch
        定义了项目在交叉轴上的对齐方式
    * align-content: flex-start | flex-end | center | space-between | space-around | stretch
        定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
- 项目的属性
    * order
        定义了项目的排列顺序。数值越小，排列越靠前，默认为0。
    * flex-grow
        定义项目的放大比例，默认为0。即如果存在剩余空间，也不放大。
        如果所有的项目的flex-grow属性都为1，则他们将等分剩余空间（如果有的话）。
        如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
    * flex-shrink
        定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
        如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。
        如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
        负值对该属性无效
    * flex-basis
        定义了在分配多余空间之前，项目占据的主轴空间。
        浏览器根据这个属性，计算主轴是否有多余空间。
        他的默认值为auto，即项目的本来大小。
    * flex
        是flex-grow，flex-shrink和flex-basis的简写，默认值是0 1 auto。后两个属性可选。
        该属性有两个快捷值：auto（1 1 auto）和none（0 0 auto）。
        建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
    * align-self: auto | flex-start | flex-end | center | baseline | stretch
        允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 

###css优先级
从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0
内联样式和外联样式的优先级和加载顺序有关
!important > 行内样式 > 内联样式 and 外联样式
1. 常用选择器权重优先级：!important > id > class > tag
2. !important可以提升样式优先级，但不建议使用。如果!important被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被应用上!important。 例如：background: blue !important;
3. 如果两条样式都使用!important，则权重值高的优先级更高
4. 在css样式表中，同一个CSS样式你写了两次，后面的会覆盖前面的
5. 样式指向同一元素，权重规则生效，权重大的被应用
6. 样式指向同一元素，权重规则生效，权重相同时，就近原则生效，后面定义的被应用
7. 样式不指向同一元素时，权重规则失效，就近原则生效，离目标元素最近的样式被应用

###层叠上下文 [Try It](./demo/stackingContext.html) [Detail](https://juejin.im/post/5b876f86518825431079ddd6)
元素提升为一个比较特殊的图层 在三维空间中（Z轴）高出普通元素一等
* 触发条件
    * 根层叠上下文（html）
    * position
    * css3属性
        * flex
        * transform
        * opacity
        * filter
        * will-change
        * -webkit-overflow-scrolling
* 层叠等级：层叠上下文在Z轴上的排序
    * 在同一层叠上下文中 层叠等级才有意义
    * z-index的优先级最高
![image](./images/stackingContext.png)
> 1. 首先先看要比较的两个元素是否处于同一个层叠上下文中：
> * 如果是，谁的层叠等级大，谁在上面（怎么判断层叠等级大小呢？——看“层叠顺序”图）。
> * 如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级。
> 2. 当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。
