###浏览器工作原理（主流程）
- 浏览器的主要组件
1. 用户界面
包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面
2. 浏览器引擎
在用户界面和呈现引擎之间传送指令
3. 呈现引擎
负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上
Firefox 使用的是 Gecko
Safari 和 Chrome 浏览器使用的都是 WebKit
4. 网络
用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现
5. 用户界面后端
用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法
6. JavaScript解析器
用于解析和执行 JavaScript 代码
7. 数据存储
这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库
* 值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程
- 主流程
呈现引擎一开始会从网络层获取请求文档的内容。
呈现引擎将开始解析HTML文档，并将各标记逐个转化成内容树上的DOM节点。
同时解析外部CSS文件以及样式元素中的样式数据。
HTML中这些带有视觉指令的样式信息将用于创建呈现树。
呈现树构建完毕之后，进入布局处理阶段，为每个节点分配一个应出现在屏幕上的确切坐标。
下一个阶段是绘制，呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。
这是一个渐进的过程。为了达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。
不必等到整个HTML文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。
![image](./images/呈现引擎主流程.png)

###行内元素和块级元素
- 块级元素
1. 总是在新行上开始，占据一整行；
2. 高度，行高以及外边距和内边距都可控制；
3. 宽度始终是与浏览器宽度一样，与内容无关；
4. 它可以容纳内联元素和其他块元素
- 行内元素
1. 和其他元素都在一行上；
2. 高，行高及外边距和内边距部分可改变；
3. 宽度只与内容有关；
4. 行内元素只能容纳文本或者其他行内元素。
不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，
内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，
也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用

###同源策略
- 什么是同源
所谓的同源是一种安全机制，为了预防某些恶意行为（例如 Cookie 窃取等），浏览器限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。
而满足同源要具备三方面：协议相同、域名相同、端口相同
- 什么地方需要同源
    1. Ajax通信
    2. Cookie
    3. LocalStorage
    4. IndexDB
    5. DOM的操作

###跨域资源共享
1. CORS 
实现CORS需要浏览器与服务器的同时支持。  
浏览器会为请求添加Origin头，其包含页面的源信息（协议、域名和端口）  
Origin: http://domain.com  
如果服务器认为该请求可接受，就在Access-Control-Allow-Origin头部中回发相同的源信息。  
要注意的是请求和响应都不包含Cookie信息。  
现代浏览器都对 CORS 提供了原生支持（IE8、9 是利用XDomainRequest，不过已废弃），无需编写额外代码即可触发简单的跨域行为，因为浏览器会自动帮你添加一些头部信息，但是有以下限制：  
a. 不可使用setRequestHeader()设置自定义头部。  
b. 默认情况下不能请求 Cookie 等凭据，除非服务器在响应头中将Access-Control-Allow-Credentials设为true。  
c. 调用getAllResponseHeaders()会返回空字符串。  
对于非简单请求，它会在正式通信之前，增加一次http查询请求，称为"预检"请求（preflight）。  
通常是一个OPTION请求。这个请求先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪http动词和头信息字段。  
只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错  
2. 图像Ping  
该跨域技术主要是利用<img>标签设置src属性（请求地址通常都带有查询字符串），然后监听该<img>的onload或onerror事件来判断请求是否成功。响应的内容通常是一张 1 像素的图片或者204响应。  
图片 Ping 有两个缺点：  
    a. 因为是通过<img>标签实现，所以只支持GET请求。  
    b. 无法访问服务器响应脚本，只能用于在浏览器与服务器之间进行单向通行。  
3. JSONP  
JSONP 是 JSON with padding 的简写，其主要是利用动态创建script标签向服务器发送 GET 请求，  
服务器收到请求后将数据放在一个指定名字的回调函数中并传送回来  
```javascript
//对创建标签行为进行封装
function addScriptTag(src) {
  var script = document.createElement('script')
  script.setAttribute("type","text/javascript")
  script.src = src
  document.body.appendChild(script)
}

//当浏览器加载完毕时向服务器发送请求
window.onload = function () {
  addScriptTag('http://domain.com/data?callback=getdata')
}

//服务器收到上面的请求后，将数据放在回调函数的参数（data）中返回
function getdata(data) {
  console.log(data)
}

//服务器获取参数名后，将回调函数和参数拼接为字符串返回
response.send(
  `${query.callback}({
    "name": "Hello"
  })`
)
```  
4. 其他跨域的方法  
* HTML5的postMessage
* WebSocket（当然协议就不一样了）
* document.domain（iframe）
* location.hash（iframe）
* window.name
* nginx 反向代理

###跨页面通信  
- 同源页面的跨页面通信  
1. BroadCast Channel  
Broadcast Channel 会创建一个所有同源页面都可以共享的（广播）频道，因此其中某一个页面发送的消息可以被其他页面监听到  
2. Service Worker  

- 非同源页面的跨页面通信  

