###浏览器工作原理（主流程）
- 浏览器的主要组件
1. 用户界面
包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面
2. 浏览器引擎
在用户界面和呈现引擎之间传送指令
3. 呈现引擎
负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上
Firefox 使用的是 Gecko
Safari 和 Chrome 浏览器使用的都是 WebKit
4. 网络
用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现
5. 用户界面后端
用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法
6. JavaScript解析器
用于解析和执行 JavaScript 代码
7. 数据存储
这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库
* 值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程
- 主流程
呈现引擎一开始会从网络层获取请求文档的内容。
呈现引擎将开始解析HTML文档，并将各标记逐个转化成内容树上的DOM节点。
同时解析外部CSS文件以及样式元素中的样式数据。
HTML中这些带有视觉指令的样式信息将用于创建呈现树。
呈现树构建完毕之后，进入布局处理阶段，为每个节点分配一个应出现在屏幕上的确切坐标。
下一个阶段是绘制，呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。
这是一个渐进的过程。为了达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。
不必等到整个HTML文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。
![image](./images/呈现引擎主流程.png)

###行内元素和块级元素
- 块级元素
1. 总是在新行上开始，占据一整行；
2. 高度，行高以及外边距和内边距都可控制；
3. 宽度始终是与浏览器宽度一样，与内容无关；
4. 它可以容纳内联元素和其他块元素
- 行内元素
1. 和其他元素都在一行上；
2. 高，行高及外边距和内边距部分可改变；
3. 宽度只与内容有关；
4. 行内元素只能容纳文本或者其他行内元素。
不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，
内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，
也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用

###同源策略
- 什么是同源
所谓的同源是一种安全机制，为了预防某些恶意行为（例如 Cookie 窃取等），浏览器限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。
而满足同源要具备三方面：协议相同、域名相同、端口相同
- 什么地方需要同源
    1. Ajax通信
    2. Cookie
    3. LocalStorage
    4. IndexDB
    5. DOM的操作

###跨域资源共享
1. CORS 
实现CORS需要浏览器与服务器的同时支持。  
浏览器会为请求添加Origin头，其包含页面的源信息（协议、域名和端口）  
Origin: http://domain.com  
如果服务器认为该请求可接受，就在Access-Control-Allow-Origin头部中回发相同的源信息。  
要注意的是请求和响应都不包含Cookie信息。  
现代浏览器都对 CORS 提供了原生支持（IE8、9 是利用XDomainRequest，不过已废弃），无需编写额外代码即可触发简单的跨域行为，因为浏览器会自动帮你添加一些头部信息，但是有以下限制：  
a. 不可使用setRequestHeader()设置自定义头部。  
b. 默认情况下不能请求 Cookie 等凭据，除非服务器在响应头中将Access-Control-Allow-Credentials设为true。  
c. 调用getAllResponseHeaders()会返回空字符串。  
对于非简单请求，它会在正式通信之前，增加一次http查询请求，称为"预检"请求（preflight）。  
通常是一个OPTION请求。这个请求先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪http动词和头信息字段。  
只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错  
2. 图像Ping  
该跨域技术主要是利用<img>标签设置src属性（请求地址通常都带有查询字符串），然后监听该<img>的onload或onerror事件来判断请求是否成功。响应的内容通常是一张 1 像素的图片或者204响应。  
图片 Ping 有两个缺点：  
    a. 因为是通过<img>标签实现，所以只支持GET请求。  
    b. 无法访问服务器响应脚本，只能用于在浏览器与服务器之间进行单向通行。  
3. JSONP  
JSONP 是 JSON with padding 的简写，其主要是利用动态创建script标签向服务器发送 GET 请求，  
服务器收到请求后将数据放在一个指定名字的回调函数中并传送回来  
```javascript
//对创建标签行为进行封装
function addScriptTag(src) {
  var script = document.createElement('script')
  script.setAttribute("type","text/javascript")
  script.src = src
  document.body.appendChild(script)
}

//当浏览器加载完毕时向服务器发送请求
window.onload = function () {
  addScriptTag('http://domain.com/data?callback=getdata')
}

//服务器收到上面的请求后，将数据放在回调函数的参数（data）中返回
function getdata(data) {
  console.log(data)
}

//服务器获取参数名后，将回调函数和参数拼接为字符串返回
response.send(
  `${query.callback}({
    "name": "Hello"
  })`
)
```  
4. 其他跨域的方法  
* HTML5的postMessage
* WebSocket（当然协议就不一样了）
* document.domain（iframe）
* location.hash（iframe）
* window.name
* nginx 反向代理

###跨页面通信  todo
- 同源页面的跨页面通信  
1. BroadCast Channel  
Broadcast Channel 会创建一个所有同源页面都可以共享的（广播）频道，因此其中某一个页面发送的消息可以被其他页面监听到  
2. Service Worker  

- 非同源页面的跨页面通信  

###两种路由模式  
在单页应用中，单纯改变浏览器地址，页面不会重载。路由主要是通过监听事件，并利用JavaScript实现动态改变页面内容，有两种实现方式：  
- hash模式  
使用window.location.hash属性以及onhashchange事件，监听浏览器地址hash值变化，执行相应的js切换网页  
1. hash指的是地址中#号以及后面的字符，也称为散列值  
2. 散列值是不会随请求发送的服务器端的，所以改变hash，不会重新加载页面  
3. 监听window的hashchange事件，当散列值改变时，可以通过location.hash来获取和设置hash值  
4. location.hash值的变化会直接反应到浏览器地址栏
- history模式  
利用history API实现url地址改变，网页内容改变  
* window.history属性指向History对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。  
* History对象保存了当前窗口访问过的所有页面地址。通过history.length可以得出当前窗口一共访问过几个网址。  
* 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。  
* 浏览器工具的前进和后退按钮，其实就是对History对象进行操作。  
History对象的主要属性  
* lenght: 当前窗口访问过的网址数量（包括当前网页）  
* state: History堆栈最上层的状态值  
History对象的方法  
* back: 移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果
* forward: 移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果
* go: 接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面
* pushState: 该方法用于在历史中添加一条记录。不会触发页面刷新，只是导致History对象发生变化，地址栏也会有变化。  
    语法: history.pushState(object, title, url)  
    object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。
    title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。
    url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。
* replaceState: 该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样
- popState事件  
每当 history 对象出现变化时，就会触发 popstate 事件  
* 仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件;
* 只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。
* 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。
* 页面第一次加载的时候，浏览器不会触发popstate事件。
history 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面
- 区别  
hash会在浏览器地址后面增加#号，而history可以自定义地址

###DOM树  
- 什么是DOM  
HTML文件字节流无法被渲染引擎理解，需要将其转化为渲染引擎能够理解的结构，这个结构就是DOM（document object model，文档对象模型）  
DOM提供了对HTML文档结构化的表述，在渲染引擎中DOM有三个层面的作用：  
1. 从页面的视角来看，DOM是生成页面的基础数据结构  
2. 从JavaScript脚本角度来看，DOM提供给JavaScript脚本操作的接口，通过这套接口，JavaScript可以对DOM结构进行访问，从而改变文档的结构、内容和样式  
3. 从安全角度来看，DOM是一道安全防护线，一些不安全的内容在DOM解析阶段就被拒之门外了  
DOM是表述HTML的内部数据结构，它会将Web页面和JavaScript脚本连接起来，并过滤一些不安全的内容  
- DOM树如何生成  
1. 网络进出接收到content-type是text/html的文件，选择或者创建一个渲染进程，并建立一个共享数据的管道，讲接收到的数据不断放进管道（所以HTML解析器是随着HTML文档边加载边解析的）  
2. 通过分词器将字节流转换为Token
3. 将Token解析为DOM节点，并将DOM节点添加到DOM树中  
    * 如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
    * 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
    * 如果分词器解析出来的是EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。  
通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。  
- JavaScript如何影响DOM生成  
1. 执行到JavaScript标签的时候会暂停整个DOM的解析（因为JavaScript脚本可能会修改当前已经生成的DOM结构）  
2. 下载外部JavaScript脚本也会阻塞DOM解析（可以使用CDN、压缩文件体积、没有DOM相关操作的脚本可以设置为异步加载(async，defer)）
async: 加载完成立即执行  
defer: 在DOMContentLoaded事件之前执行  
3. 渲染引擎在遇到JavaScript脚本时，不管该脚本是否操纵了CSSOM，都会执行CSS文件下载，解析操作，再执行JavaScript脚本。JavaScript会阻塞DOM生成，而样式文件又会阻塞JavaScript的执行。

###事件模型  
浏览器的事件模型就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式的主要编程方式。  
- 绑定事件的三种方式  
1. HTML的on-属性  
on-属性的值是原样传入JavaScript引擎执行。因此如果要执行函数，需要加上圆括号  
使用这个方法指定的监听代码，只会在冒泡阶段触发
2. 元素节点的事件属性  
使用这个方法指定的监听代码，只会在冒泡阶段触发
与HTML的on-属性的差异是，它的值是函数名
3. EventTarget.addEventListener()  
所有DOM节点实例都有addEventListener方法，用来为该节点定义事件的监听函数  
上面三种方法，HTML的on-属性违反了HTML与JavaScript代码相分离的原则，讲两者写在一起，不利于代码分工，不推荐使用。  
元素节点的事件属性的缺点在于，同一个事件只能定义一个监听函数，如果定义两次onclick属性，后一次会覆盖前一次，不推荐使用。 
EventTarget.addEventListener是推荐的指定监听函数的方法。它有如下优点：  
同一个事件可以添加多个监听函数。  
能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。 (第三个参数true就是捕获阶段，false是冒泡阶段) 
除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个JavaScript统一的监听函数接口。  
- 事件的传播  
一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段：  
1. 捕获阶段：从window对象传导到目标节点（上层传到底层）  
2. 目标阶段：在目标节点上触发  
3. 冒泡阶段：从目标节点传导回window对象（从底层传回上层）  
注意：浏览器总是假定click事件的目标节点，就是点击位置嵌套最深的那个节点  
事件传播的最上层对象是window，接着依次是document，html和body。  
- 事件的代理  
由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。  
如果希望事件到某个节点为止，不再传播，可以使用事件对象的stopPropagation方法  
```javascript
// 事件传播到p元素后就不再向下传播了
p.addEventListener('click', function(event) {
  event.stopPropagation();
}, true)
// 事件传播到p元素后就不再向上冒泡了
p.addEventListener('click', function(event) {
  event.stopPropagation();
}, false)
```
如果想彻底取消事件，不再出发后面的监听函数，可以使用stopImmediatePropagation方法  

###浏览器缓存策略  
浏览器的缓存机制也就是HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的  
- 缓存的过程  
* 浏览器每次发起请求，都会现在浏览器缓存中查找该请求的结果以及缓存标识  
* 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中  
根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分  
- 强制缓存  
1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求  
2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存  
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果  
强制缓存的缓存规则:  
当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高  
- Expires  
HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值，直接使用缓存结果  
到了HTTP/1.1，Expires已经被Cache-Control替代，原因在于客户端与服务端的时间容器发生误差，强制缓存会直接失效  
- Cache-Control  
Cache-Control取值  
* public: 所有内容都将被缓存（客户端和代理服务器都可缓存）  
* private: 所有内容只有客户端可以缓存（默认值）  
* no-cache: 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定  
* no-store: 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存  
* max-age=xxx(xxx is numeric): 缓存内容将在xxx秒后失效  
在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效  
- 缓存内容的存放方式  
* memory cache  
快速读取: 将解析后的文件存入该进程的内存中，占据一定的内存资源，以方便下次运行使用时的快速读取  
时效性: 一旦该进程关闭，则该进程的内存会清空  
* disk cache  
将缓存写入硬盘文件中，读取需要对硬盘文件进行I/O操作，然后重新解析缓存内容，读取复杂，速度比内存缓存慢  
在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；  
而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)
- 协商缓存  
在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。  
协商缓存生效，返回304  
协商缓存失效，返回200和请求结果  
- 控制协商缓存的字段  
Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高  
* Etag / If-None-Match  
Etag是服务器响应请求时，返回该资源文件的一个唯一标识（有服务器生成）  
If-None-Match则是客户端再次发起请求时，携带上次请求返回的Etag是服务器响应请求时值，通过此字段值告诉服务器该资源上次请求返回的唯一标识。  
服务器收到该请求，发现请求头含有If-None-Match的字段值与该资源在服务器的Etag做对比，  
如果不一致，则重新返回资源，状态码为200；否则则返回304，代表资源无更新。
* Last-Modified / If-Modified-Since  
Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间  
If-Modified-Since则是客户端再次发起请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。  
服务器收到该请求，发现请求头含有If-Modified-Since的字段值与该资源在服务器的最后被修改时间最对比，  
若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新。  
总结：强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，  
协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存  

###内存泄漏  
- 内存的生命周期  
内存分配->内存使用->内存释放  
- 内存泄漏  
无用的内存还在占用，得不到释放和归还。严重时，无用的内存会持续递增，从而导致整个系统卡顿，甚至崩溃。  
- 内存回收  
一般称为垃圾内存回收（Garbage Collection, GC），内存泄漏一般都是发生在这一步，JavaScript的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况，如果存在这些情况，需要我们手动清理内存。  
JavaScript垃圾内存的两种回收方式  
* 引用计数垃圾收集  
如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收  
```javascript
// 将该对象分配给a
var a = {}
// b引用这个对象
var b = a
// 该对象的原始引用a被b替换了
a = 1
// 手动释放这个对象
b = null
```
ES6把引用区分为强引用和弱引用，目前只有在Set和Map中才有。  
强引用会有引用计数叠加，只有引用计数为0的对象的内存才会被回收，所以一般需要手动回收内存（手动回收的前提是标记清除法还没执行，还处于当前执行环境）  
弱引用没有触发引用计数叠加，只要引用计数为0，弱引用就会自动消失，无需手动回收内存  
* 标记清除法  
当变量进入执行环境时标记为‘进入环境’，当变量离开执行环境时则标记为‘离开环境’，被标记‘进入环境’的变量是不能被回收的，因为他们正在被使用，而标记为‘离开环境’的变量则可以被回收  
```javascript
// 假设这里是全局变量
// b 被标记进入环境
var b = 2;
function test() {
  var a = 1;
  // 函数执行时，a 被标记进入环境
  return a + b;
}
// 函数执行结束，a 被标记离开环境，被回收
// 但是 b 就没有被标记离开环境
test();
```
- JavaScript内存泄漏的场景  
* 意外的全局变量  
```javascript
// 在全局作用域下定义
function count(number) {
  // basicCount 相当于 window.basicCount = 2;
  basicCount = 2;
  return basicCount + number;
}
```
* 被遗忘的计数器  
setTimeout之类的计数器没有被清除（clearTimeout）  
* 被遗忘的事件监听  
addEventListener没有执行removeEventListener  
* 被遗忘的Map键名/Set成员  
```javascript
let set = new Set();
let value = { test: 22};
set.add(value);
// set.delete(value);

value= null;

let map = new Map();
let key = new Array(5 * 1024 * 1024);
map.set(key, 1);
// map.delete(key);

key = null;
```
可以使用WeakMap/WeakSet  
* 脱离DOM的引用  
```javascript
class Test {
  constructor() {
    this.elements = {
      button: document.querySelector('#button'),
      div: document.querySelector('#div'),
      span: document.querySelector('#span'),
    }
  }
  removeButton() {
    document.body.removeChild(this.elements.button)
    // this.elements.button = null
  }
}

const a = new Test()
a.removeButton()
```
- 如何发现内存泄漏  
内存泄漏时，内存一般都是周期性的增长，可以借助Chrome的开发者工具进行判断。  
1. 确定是否是内存泄漏问题  
打开谷歌开发者工具，切换至Performance选项，勾选Memory选项，点击左上角的录制按钮
2.查找内存泄漏出现的位置  
打开谷歌开发者工具，切换至 Memory 选项，点击开发者工具左上角录制按钮，录制完成后继续点击录制
录 JavaScript 堆内存才是内存录制的主要目的，我们可以看到哪个堆占用的内存更高  
按照 Shallow Size 进行逆序排序
