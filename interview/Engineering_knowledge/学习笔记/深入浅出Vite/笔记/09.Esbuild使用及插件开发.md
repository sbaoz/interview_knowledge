<!--
 * @Author: sbaoz xiaojz821@hotmail.com
 * @Date: 2022-07-18 09:16:28
 * @LastEditors: sbaoz xiaojz821@hotmail.com
 * @LastEditTime: 2022-11-14 14:49:54
 * @FilePath: \interview_knowledge\interview\Engineering_knowledge\学习笔记\深入浅出Vite\笔记\09.Esbuild使用及插件开发.md
 * @Description: Esbuild Build API的使用 build buildSyn serve
-->
#### Esbuild高性能的主要原因
- 使用Golong开发 直接编译为原生机器码 节省程序运行时间
- 多核并行
- 几乎没有使用第三方库
- 高效利用内存 复用一份AST节点数据

#### Esbuild功能使用
调用方式有2种 命令行调用和代码调用 命令行不适用复杂场景 所以一般使用代码调用  
Esbuild主要包括2类API Build API和Transform API  
- Build API 主要用来进行项目打包
  - build
  - buildSync
    不推荐使用  
    - 使Esbuild在当前线程阻塞 丧失并发任务处理的优势 
    - 给插件开发增加了限制 所有插件中都不能使用任何异步操作
  - serve 
    只适合在开发阶段使用 不适用于生产环境
    - 开启 serve 模式后，将在指定的端口和目录上搭建一个静态文件服务，这个服务器用原生 Go 语言实现，性能比 Nodejs 更高
    - 类似 webpack-dev-server，所有的产物文件都默认不会写到磁盘，而是放在内存中，通过请求服务来访问
    - 每次请求到来时，都会进行重新构建(rebuild)，永远返回新的产物
      触发 rebuild 的条件并不是代码改动，而是新的请求到来

- Transform API 单文件转译
  - transformSync
    和buildSync类似 不推荐使用
  - transform
    Vite 的底层实现也是采用 transform这个异步的 API 进行 TS 及 JSX 的单文件转译的

#### Esbuild插件开发
插件开发就是基于原有的体系结构中进行扩展和自定义  
Esbuild插件结构是一个对象 里面有name（插件的名称）和setup（一个函数 入参是一个build对象）两个属性  
build对象上挂载了一些钩子函数 可供自定义函数逻辑  

#### 钩子函数的使用
- onResolve钩子和onLoad钩子
  - onResolve 控制路径解析
  - onLoad 控制模块内容加载
  - 这2个钩子函数都需要传入两个参数 Options和Callback  
    - Options 包含filter和namespace两个属性
      - filter 必传 是一个正则表达式（Go原生正则 考虑到性能所以要尽可能严格） 决定了要过滤出的特征文件
      - namespace 选填 在onResolve的回调中返回namespace 可以在onLoad中通过namespace将模块过滤出来
    - Callback 常用属性
    ```js
    build.onResolve({ filter: /^env$/ }, (args: onResolveArgs): onResolveResult => {
      // 模块路径
      console.log(args.path)
      // 父模块路径
      console.log(args.importer)
      // namespace 标识
      console.log(args.namespace)
      // 基准路径
      console.log(args.resolveDir)
      // 导入方式，如 import、require
      console.log(args.kind)
      // 额外绑定的插件数据
      console.log(args.pluginData)
      
      return {
        // 错误信息
        errors: [],
        // 是否需要 external
        external: false;
        // namespace 标识
        namespace: 'env-ns';
        // 模块路径
        path: args.path,
        // 额外绑定的插件数据
        pluginData: null,
        // 插件名称
        pluginName: 'xxx',
        // 设置为 false，如果模块没有被用到，模块代码将会在产物中会删除。否则不会这么做
        sideEffects: false,
        // 添加一些路径后缀，如`?xxx`
        suffix: '?xxx',
        // 警告信息
        warnings: [],
        // 仅仅在 Esbuild 开启 watch 模式下生效
        // 告诉 Esbuild 需要额外监听哪些文件/目录的变化
        watchDirs: [],
        watchFiles: []
      }
    }

    build.onLoad({ filter: /.*/, namespace: 'env-ns' }, (args: OnLoadArgs): OnLoadResult => {
      // 模块路径
      console.log(args.path);
      // namespace 标识
      console.log(args.namespace);
      // 后缀信息
      console.log(args.suffix);
      // 额外的插件数据
      console.log(args.pluginData);
      
      return {
        // 模块具体内容
        contents: '省略内容',
        // 错误信息
        errors: [],
        // 指定 loader，如`js`、`ts`、`jsx`、`tsx`、`json`等等
        loader: 'json',
        // 额外的插件数据
        pluginData: null,
        // 插件名称
        pluginName: 'xxx',
        // 基准路径
        resolveDir: './dir',
        // 警告信息
        warnings: [],
        // 同上
        watchDirs: [],
        watchFiles: []
      }
    });
    ```
- 其他钩子
  - onStart 和 onEnd 构建开启和结束时执行一些自定义的逻辑  
  ```js
  let examplePlugin = {
  name: 'example',
  setup(build) {
      build.onStart(() => {
        console.log('build started')
      });
      build.onEnd((buildResult) => {
        if (buildResult.errors.length) {
          return;
        }
        // 构建元信息
        // 获取元信息后做一些自定义的事情，比如生成 HTML
        console.log(buildResult.metafile)
      })
    },
  }
  ```
  - onStart 的执行时机是在每次build的时候 包括触发watch或者serve模式下的重新构建
  - onEnd钩子中如果要拿到metafile 必须将EsBuild的构建配置中metafile属性设为true