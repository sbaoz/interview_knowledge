<!--
 * @Author: sbaoz xiaojz821@hotmail.com
 * @Date: 2022-07-11 13:33:16
 * @LastEditors: sbaoz xiaojz821@hotmail.com
 * @LastEditTime: 2022-07-11 17:01:52
 * @FilePath: \interview_knowledge\interview\Engineering_knowledge\学习笔记\深入浅出Vite\笔记\02.模块化标准.md
 * @Description: 模块化标准
-->
#### 无模块标准阶段
- 文件划分  
  - 引起变量名冲突
  - 不知道变量属于哪个模块 调试困难
  - 无法清晰的管理模块之间依赖关系和加载顺序
- 命名空间
- IIFE  
`命名空间和IIFE解决了命名冲突和作用域不明确的问题 但是没有解决模块加载的问题`

#### 主流的模块规范  
对于模块规范而言 一般包括2个方面  
- 统一的模块化代码规范
- 实现自动加载模块的加载器

#### CommonJS
业界最早正式提出的JavaScript模块规范 主要用于服务端
```
const { xxx } = require('./xxx/xx.js') // 导入一个模块

module.exports = { yyy } // 导出一个模块
```
Node.js内部会有相应的loader转译模块代码
```
(function (exports, require, module, __filename, __dirname) {
  // 执行模块代码
  // 返回 exports 对象
});
```
存在的问题
- CommonJS模块无法直接再浏览器中执行 产生了browserify来支持打包CommonJS模块在浏览器中执行
- CommonJS本身约定以同步的方式进行模块加载 这种机制对于服务端是没有问题的 但是在浏览器中模块请求会造成JavaScript解析过程的阻塞 导致页面加载速度缓慢
  - 模块都在本地 不需要网络IO
  - 服务启动时才会加载模块 通常启动后会一直运行 不影响性能  
#### AMD
AMD全称asynchronous module definition 即异步模块定义规范  
解决了CommonJS规范在浏览器中同步加载产生的解析过程阻塞问题  
```
// print.js
define(function() {  // 通过define去定义或加载一个模块
    return {  // 通过return导出成员
        print: function(msg) {
            console.log('print ' + msg)
        }
    }
}) 

// main.js
define(['./print'], function(printModule) {  // 通过define的第一个参数来声明依赖模块 模块的代码执行之前浏览器会先加载依赖模块
    printModule.print('main')
})
```
AMD没有原生浏览器支持 需要第三方loader来实现 最经典的就是requireJS库  
类似的CMD规范 由淘宝出品的SeaJS 已经被requireJS兼容  
UMD规范是兼容AMD和CommonJS的一个模块化方案 提供了同时运行在浏览器和Node.js环境的跨平台方案  
存在的问题
- 使用复杂 代码阅读和书写都比较困难 仅仅是一个妥协性的方案  

#### ES Module
由ECMAScript官方提出的模块化方案 已经得到现代浏览器的内置支持 覆盖了90%以上的浏览器 script标签加入type='module'的属性 浏览器就会按照ESModule规范来进行依赖加载和模块解析 这也是Vite在开发阶段实现no-bundle的原因  
CommonJS从12.20版本开始正式支持原生ESModule 使ESModule能够同时在浏览器和Node.js环境中执行 拥有跨平台能力  
如果要在Node.js环境中执行 需要在package.json中声明type: "module"属性  
在Node.js中 即使是在CommonJS模块里面也可以通过import方法加载ES模块 文件名后缀需要是.mjs