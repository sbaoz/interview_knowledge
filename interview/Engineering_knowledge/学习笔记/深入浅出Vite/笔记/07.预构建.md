<!--
 * @Author: sbaoz xiaojz821@hotmail.com
 * @Date: 2022-07-14 17:04:37
 * @LastEditors: sbaoz xiaojz821@hotmail.com
 * @LastEditTime: 2022-07-15 11:15:37
 * @FilePath: \interview_knowledge\interview\Engineering_knowledge\学习笔记\深入浅出Vite\笔记\07.预构建.md
 * @Description: Vite 预构建技术的作用和预构建相关配置的使用
 * 预构建的相关配置——entries、include、exclude和esbuldOptions
 * 重点介绍了include配置的各种使用场景和使用姿势
 * 第三方包出现了问题该怎么办
 * 
-->
#### 为什么需要预构建
Vite是基于浏览器原生ES模块规范实现Dev Server 不论业务代码还是第三方依赖代码 都要符合ESM规范才能运行  
但是很多第三方库没有ES版本的产物 所以需要将它转换成ESM格式的产物  
此外有些库在加载时会发出特别多的请求（请求瀑布流问题）导致页面加载的前几秒处于卡顿状态（Chrome对同一个域名下同时支持6个HTTP并发）  
进行依赖的预构建后 第三方库的代码会被打包成一个文件 减少请求的数量 页面加载速度加快  

依赖预构建做了两件事情：  
- 将其他格式的产物（CJS和UMD）转换成ESM格式
- 打包第三方库的代码 将分散的文件合并在一起

Vite 中有两种开启预构建的方式，分别是自动开启和手动开启

预构建产物文件存放的目录 node_modules/.vite  
Dev Tools 中的网络调试面板，可以发现第三方包的引入路径已经被重写  
对于依赖的请求结果，Vite 的 Dev Server 会设置强缓存 缓存过期时间被设置为一年  

以下 3 个地方都没有改动，Vite 将一直使用缓存文件:  
- package.json 的 dependencies 字段
- 各种包管理器的 lock 文件
- optimizeDeps 配置内容

推荐使用下面任意一种方法清除缓存，还有手动开启预构建:  
- 删除node_modules/.vite目录。
- 在 Vite 配置文件中，将server.force设为true。
- 命令行执行npx vite --force或者npx vite optimize

Vite 项目的启动可以分为两步，第一步是依赖预构建，第二步才是 Dev Server 的启动，npx vite optimize相比于其它的方案，仅仅完成第一步的功能。

#### 预构建配置详解
预构建配置项集中在optimizeDeps属性上  
- entries  
  Vite默认抓取项目中所有的HTML文件作为应用入口 然后根据入口文件扫描出项目中用到的第三方依赖 对这些依赖进行编译  
  当默认扫描HTML文件的行为不能满足需求时 通过entries参数来配置 支持glob语法  
  ```
  entries: ['./index.html']
  ```
- include  
  可以强制预构建的依赖项 按需加载的依赖都可以声明到这个数组里  
  ```
  include: ['loadash-es']
  ```
  某些情况下Vite默认的扫描行为不完全可靠 需要联合配置include达到完美的预构建效果  
  场景1：动态import  
  由于Vite有按需加载的特性 会导致某些依赖只能在运行时被识别出来 随之会重新进行依赖预构建 并刷新画面（二次预构建） 会拖慢应用的加载速度 要尽力避免  
  ```
  include: ['object-assign'] // 按需加载的依赖都可以声明到这个数组里
  ```
  场景2：手动exclude的包中某个依赖没有提供ESM格式的产物 导致加载失败 在include中将所有不具备 ESM 格式产物包都声明一遍  
  ```
  include: ["@loadable/component > hoist-non-react-statics"] // 接依赖的声明语法，通过`>`分开, 如`a > b`表示 a 中依赖的 b
  ```
- esbuildOptions  
  Vite 提供了esbuildOptions 参数来让我们自定义 Esbuild 本身的配置，常用的场景是加入一些 Esbuild 插件
  ```
  esbuildOptions: {
   plugins: [
     // 加入 Esbuild 插件
   ];
  }
  ```
  这个配置主要用来处理一些特殊情况  
  场景1：第三方包出现问题  
  - 直接修改第三方库的代码  
  以修改react-virtualized库的ESM产物为例  
  ```
  pnpm i @milahu/patch-package -D // 这个库能记录第三方库代码的改动，另一方面也能将改动同步到团队每个成员
  ```
  注意: 要改动的包在 package.json 中必须声明确定的版本，不能有~或者^的前缀。  
  进入第三方库进行修改 再在终端中执行如下命令
  ```
  npx patch-package react-virtualized
  ```
  根目录会多出patches目录记录第三方包内容的更改，随后我们在package.json的scripts中增加如下内容
  ```
  "postinstall": "patch-package"
  ```
  这样一来，每次安装依赖的时候都会通过 postinstall 脚本自动应用 patches 的修改，解决了团队协作的问题  
  - 加入Esbuild插件
  通过Esbuild插件修改指定模块的内容  
  vite.config.ts 配置如下  
  ```
    const esbuildPatchPlugin = {
    name: "react-virtualized-patch",
    setup(build) {
        build.onLoad(
        {
            filter:
            /react-virtualized\/dist\/es\/WindowScroller\/utils\/onScroll.js$/,
        },
        async (args) => {
            const text = await fs.promises.readFile(args.path, "utf8");

            return {
            contents: text.replace(
                'import { bpfrpt_proptype_WindowScroller } from "../WindowScroller.js";',
                ""
            ),
            };
        }
        );
    },
    };

    // 插件加入 Vite 预构建配置
    {
    optimizeDeps: {
        esbuildOptions: {
        plugins: [esbuildPatchPlugin];
        }
    }
  }
  ```
