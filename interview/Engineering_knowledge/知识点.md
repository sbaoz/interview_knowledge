###模块化
- 什么是模块化
  * 将一个复杂的程序依据一定的规则封装成几个块，并进行组合在一起
  * 块的内部数据与实现是私有的，只是向外部暴露一些接口与外部其他模块通信
- 模块化的进化过程
  * 全局function模式：将不同的功能封装成不同的全局函数
    * 问题：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接联系
    ```javascript
    function m1(){
      //...
    }
    function m2(){
      //...
    }
    ``` 
  * namespace模式：简单对象封装，减少了全局变量，解决命名冲突
    * 问题：数据不安全，外部可以直接修改模块内部的数据
    ```javascript
    let myModule = {
      data: 'www.baidu.com',
      foo() {
        console.log(`foo() ${this.data}`)
      },
      bar() {
        console.log(`bar() ${this.data}`)
      }
    }
    myModule.data = 'other data' //能直接修改模块内部的数据
    myModule.foo() // foo() other data
    ```
  * IIFE模式：匿名函数自调用（闭包）
    * 作用：数据是私有的，外部只能通过暴露的方法操作
    * 编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口
    * 问题：如果当前模块依赖另一个模块怎么办
    ```javascript
    // index.html文件
    <script type="text/javascript" src="module.js"></script>
    <script type="text/javascript">
        myModule.foo()
        myModule.bar()
        console.log(myModule.data) //undefined 不能访问模块内部数据
        myModule.data = 'xxxx' //不是修改的模块内部的data
        myModule.foo() //没有改变
    </script>
    // module.js文件
    (function(window) {
      let data = 'www.baidu.com'
      //操作数据的函数
      function foo() {
        //用于暴露有函数
        console.log(`foo() ${data}`)
      }
      function bar() {
        //用于暴露有函数
        console.log(`bar() ${data}`)
        otherFun() //内部调用
      }
      function otherFun() {
        //内部私有的函数
        console.log('otherFun()')
      }
      //暴露行为
      window.myModule = { foo, bar } //ES6写法
    })(window)
    ```
  * IIFE模式增强：引入依赖
    ```javascript
    // module.js文件
    (function(window, $) {
      let data = 'www.baidu.com'
      //操作数据的函数
      function foo() {
        //用于暴露有函数
        console.log(`foo() ${data}`)
        $('body').css('background', 'red')
      }
      function bar() {
        //用于暴露有函数
        console.log(`bar() ${data}`)
        otherFun() //内部调用
      }
      function otherFun() {
        //内部私有的函数
        console.log('otherFun()')
      }
      //暴露行为
      window.myModule = { foo, bar }
    })(window, jQuery)
     // index.html文件
      <!-- 引入的js必须有一定顺序 -->
      <script type="text/javascript" src="jquery-1.10.1.js"></script>
      <script type="text/javascript" src="module.js"></script>
      <script type="text/javascript">
        myModule.foo()
      </script>
    ```  
    必须先引入jQuery库，这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显
- 模块化的好处
  * 避免命名冲突（减少命名空间污染）
  * 更好的分离，按需加载
  * 更高复用性
  * 高可维护性
- 引入多个script标签后出现问题
  * 请求过多
  * 依赖模糊
  * 难以维护
  这些问题可以通过模块化规范来解决
- 模块化规范
  * CommonsJS
    Node 应用由模块组成，采用 CommonJS 模块规范。  
    在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。  
    所有代码都运行在模块作用域，不会污染全局作用域。  
    模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。  
    模块加载的顺序，按照其在代码中出现的顺序  
    暴露模块：module.exports = value或exports.xxx = value  
    引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径  
    ```javascript
    // example.js
    var x = 5;
    var addX = function (value) {
      return value + x;
    };
    module.exports.x = x;
    module.exports.addX = addX;
    
    var example = require('./example.js'); // 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径
    console.log(example.x); // 5
    console.log(example.addX(1)); // 6
    ```
    CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值(原始类型的值)  
    Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式
  * AMD
    AMD规范是非同步加载模块，允许指定回调函数。  
    如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范  
    暴露模块：define(function(){return 模块})
  * CMD
  * ES6模块化  
    语法： export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能，export default命令为模块指定默认输出  
    与CommonJS的差异：
      1. CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用  
        ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
      2. CommonJS模块是运行时加载，ES6模块是编译时输出接口  
        因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。  
        而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
  * 总结  
      * CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。
      * AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
      * CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重
      * ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

###Tree-Shaking  
前端中的tree-shaking可以理解为通过工具"摇"我们的JS文件，将其中用不到的代码"摇"掉，是一个性能优化的范畴。  
具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。  
通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。  
Tree-shaking 和传统的 DCE的方法又不太一样，传统的DCE 消灭不可能执行的代码，而Tree-shaking 更关注于消除没有用到的代码  
- 原理  
依赖于ES6的模块特性。  
ES6 module 特点：  
1. 只能作为模块顶层的语句出现
2. import 的模块名只能是字符串常量
3. import binding 是 immutable的  
ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。  
所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。  
这是ES6 modules在设计时的一个重要考量，没有直接采用CommonJS，正是基于这个基础上，才使得tree-shaking成为可能。

