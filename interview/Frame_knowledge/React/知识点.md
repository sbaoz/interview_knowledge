###合成事件
在react中，我们绑定的事件onClick等，并不是原生事件，而是由原生事件合成的react事件。  
为什么采取这种合成事件的模式？  
1. 将事件绑定在document统一管理，避免大量节点绑定事件占用内存 
2. 抹平不同浏览器的差异
- 合成事件原理  
    1. react对事件是如何合成的  
        事件初始化阶段主要形成几个重要的对象，构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系  
        * namesToPlugins 事件名->事件模块插件的映射  
        ```javascript
        const namesToPlugins = {
            SimpleEventPlugin,
            EnterLeaveEventPlugin,
            ChangeEventPlugin,
            SelectEventPlugin,
            BeforeInputEventPlugin,
        }
        ```
        * plugins 存放上面注册的所有插件列表，初始化为空  
        * registrationNameModules 记录合成的事件-对应的事件插件的关系  
        处理props中事件的时候，会根据不同的事件名称，找到对应的事件插件，然后统一绑定在document上。  
        对于没有出现过的事件，就不会绑定。  
        ```javascript
        {
            onBlur: SimpleEventPlugin,
            onClick: SimpleEventPlugin,
            onClickCapture: SimpleEventPlugin,
            onChange: ChangeEventPlugin,
            onChangeCapture: ChangeEventPlugin,
            onMouseEnter: EnterLeaveEventPlugin,
            onMouseLeave: EnterLeaveEventPlugin,
            ...
        }
        ```
        * 事件插件  
        事件插件是一个对象，有两个属性  
        第一个extractEvent作为事件统一处理函数  
        第二个eventTypes是一个对象，保存了原生事件名和对应的配置项dispatchConfig的映射关系  
        由于v16React的事件是统一绑定在document上的，react用独特的事件名称比如onClick和onClickCapture， 来说明绑定的函数是在冒泡事件阶段，还是捕获事件阶段执行  
        以SimpleEventPlugin为例  
        ```javascript
        const SimpleEventPlugin = {
            eventTypes:{ 
                'click':{ /* 处理点击事件  */
                    phasedRegistrationNames:{
                        bubbled: 'onClick',       // 对应的事件冒泡 - onClick 
                        captured:'onClickCapture' //对应事件捕获阶段 - onClickCapture
                    },
                    dependencies: ['click'], //事件依赖
                    ...
                },
                'blur':{ /* 处理失去焦点事件 */ },
                ...
            }
            extractEvents:function(topLevelType,targetInst,){ /* eventTypes 里面的事件对应的统一事件处理函数，接下来会重点讲到 */ }
        }
        ```
        * registrationNameDependencies  
        用来记录合成事件和原生事件的对应关系  
        ```javascript
        {
            onBlur: ['blur'],
            onClick: ['click'],
            onClickCapture: ['click'],
            onChange: ['blur', 'change', 'click', 'focus', 'input', 'keydown', 'keyup', 'selectionchange'],
            onMouseEnter: ['mouseout', 'mouseover'],
            onMouseLeave: ['mouseout', 'mouseover'],
            ...
        }
        ```
       * injectEventPluginsByName() 形成上述的namesToPlugins  
       * recomputePluginOrdering() 形成上述的plugins  
       * publishEventForPlugin() 形成上述的registrationNameModules和registrationNameDependencies
    2. react事件是怎么绑定的  
       流程:  
       1. diffProperties处理react合成事件  
       ```javascript
         function diffProperties(){
             /* 判断当前的 propKey 是不是 React合成事件 */
             if(registrationNameModules.hasOwnProperty(propKey)){
                  /* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */
                  legacyListenToEvent(registrationName, document）;
             }
         }
       ```
       2. legacyListenToEvent注册事件监听器  
       ```javascript
       //  registrationName -> onClick 事件
       //  mountAt -> document or container
       function legacyListenToEvent(registrationName，mountAt){
          const dependencies = registrationNameDependencies[registrationName]; // 根据 onClick 获取  onClick 依赖的事件数组 [ 'click' ]。
           for (let i = 0; i < dependencies.length; i++) {
           const dependency = dependencies[i];
           //这个经过多个函数简化，如果是 click 基础事件，会走 legacyTrapBubbledEvent ,而且都是按照冒泡处理
            legacyTrapBubbledEvent(dependency, mountAt);
         }
       }
       ```
       在legacyListenToEvent函数中，先找到React合成事件对应的原生事件集合，然后遍历依赖项的数组，绑定事件。（只给原生绑定onChange事件，结果在document上出现很多事件监听的原因）
        按照事件捕获处理的事件：  
        ```javascript
        case TOP_SCROLL: {                                // scroll 事件
            legacyTrapCapturedEvent(TOP_SCROLL, mountAt); // legacyTrapCapturedEvent 事件捕获处理。
            break;
        }
        case TOP_FOCUS: // focus 事件
        case TOP_BLUR:  // blur 事件
        legacyTrapCapturedEvent(TOP_FOCUS, mountAt);
        legacyTrapCapturedEvent(TOP_BLUR, mountAt);
        break;
        ```
       3. 绑定dispatchEvent，进行事件监听  
       ```javascript
        /*
          targetContainer -> document
          topLevelType ->  click
          capture = false
        */
        function addTrappedEventListener(targetContainer,topLevelType,eventSystemFlags,capture){
           const listener = dispatchEvent.bind(null,topLevelType,eventSystemFlags,targetContainer) 
           if(capture){
               // 事件捕获阶段处理函数。
           }else{
               /* TODO: 重要, 这里进行真正的事件绑定。*/
              targetContainer.addEventListener(topLevelType,listener,false) // document.addEventListener('click',listener,false)
           }
        }
        ```
       真正的事件绑定,添加事件监听器addEventListener
       总结:  
       * 在React，diff DOM元素类型的fiber的props的时候，如果发现是React合成事件，比如onClick，会按照事件系统逻辑单独处理。  
       * 根据React合成事件类型，找到对应的原生事件的类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如scroll事件）。  
       * 调用addTrappedEventListener进行真正的事件绑定，绑定在document上，dispatchEvent为统一的事件处理函数。  
       * 有一点值得注意: 只有上述那几个特殊事件比如scorll,focus,blur等是在事件捕获阶段发生的，其他的都是在事件冒泡阶段发生的，无论是onClick还是onClickCapture都是发生在冒泡阶段  
    3. react事件触发流程  
    
