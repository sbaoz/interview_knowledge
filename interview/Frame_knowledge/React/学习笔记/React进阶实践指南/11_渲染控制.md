# 优化-渲染控制

- React渲染  
  对于React渲染 不仅仅是类函数触发render函数 函数组件本身执行  
  事实 上 从调度更新任务到调和fiber 再到浏览器渲染真实DOM 每一个环节都是渲染的一部分
  React底层已经处理了大部分优化细节 包括设立任务优先级 异步调度 diff算法 时间分片
  开发者只需要告诉React哪些组件需要更新
- render阶段的作用  
  render函数的作用是根据一次更新中产生的新状态值 通过React.createElement 替换成新的状态 得到新的React element对象 新的element对象上保存了最新的状态值 createElement会产生一个全新的props 到此render函数的使命完成
  接下来 React会调和由render函数产生children 将子代element变成fiber（这个过程如果存在alternate 就复用alternate进行克隆 如果没有就创建一个） 将props变成pendingProps 至此当前组件更新完毕 如果children是组件 会重复上一步 直到全部fiber调和完毕 完成render阶段

### React控制render的方法
- 从父组件直接隔断子组件的渲染 memo
- 组件从自身来控制是否render PureComponent、shouldComponentUpdate

1. 缓存React.element对象  
这是一种父对子的渲染控制方案 父组件render 子组件有没有必要跟着父组件一起render 如果没有必要 就需要阻断更新
原理：每次执行render本质上createElement会产生一个新的props 这个props将作为对应fiber的pendingProps 
在此fiber更新调和阶段 React会对比fiber上oldProps和newProps(pendingProps)是否相等 
如果相等函数组件就会放弃子组件的调和更新 从而子组件就不会重新渲染 
如果上述把element对象缓存起来 上面props也就和fiber上oldProps指向相同的内存空间 也就是相等 从而跳过了本次更新

2. PureComponent  
  纯组件是一种发自组件本身的渲染优化策略 当开发类组件选择了继承PureComponent 就意味着要遵循其渲染原则 就是浅比较state和props是否相等
  对于props PureComponent会浅比较props是否发生改变 再决定是否渲染组件
  对于state 也会浅比较处理
  浅比较只会比较基础数据类型 对于引用类型 因为浅比较还是指向同一个内存空间 所以不会触发组件更新（浅拷贝可以解决）
  原理及其浅比较原则
  当选择PureComponent继承的组件 原型链上会有isPureReactComponent属性
  > react/src/ReactBaseClasses.js
  ```javascript
  /* pureComponentPrototype 纯组件构造函数的 prototype 对象，绑定isPureReactComponent 属性。 */
  pureComponentPrototype.isPureReactComponent = true;
  ```
isPureReactComponent这个属性在更新组件updateClassInstance方法中使用
> react/react-reconciler/ReactFiberClassComponent.js
```javascript
function checkShouldComponentUpdate(){
     if (typeof instance.shouldComponentUpdate === 'function') {
         return instance.shouldComponentUpdate(newProps,newState,nextContext)  /* shouldComponentUpdate 逻辑 */
     } 
    if (ctor.prototype && ctor.prototype.isPureReactComponent) {
        return  !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
    }
}
```
isPureReactComponent就是判断当前组件是不是纯组件 如果是PureComponent会浅比较props和state是否相等
shouldComponentUpdate的权重会大于PureComponent
shallowEqual浅比较流程
1. 首先会直接比较新老props或者state是否相等 如果相等则不更新组件
2. 判断新老props或者state 有不是对象或者为null的 返回false 更新组件
3. 通过Object.keys将新老props或者state的属性名key变成数组 判断数组的长度是否相等 不相等则更新组件
4. 遍历老props或者state 判断对应的新props或者state 有没有与之对应并且相等的（这个相等是浅比较）如果有不对应或者不相等的 返回false 更新组件

PureComponent注意事项
PureComponent可以让组件自发的做一层性能上的调优 但是父组件给是PureComponent的子组件绑定事件要格外小心 避免两种情况发生
1. 避免使用箭头函数 不要给是PureComponent的子组件绑定箭头函数 因为父组件每一次render 如果是箭头函数绑定的话 都会重新生成一个新的箭头函数 PureComponent对比新老props时会判断不相等 让组件直接渲染 PureComponent作用失效
```javascript
class Index extends React.PureComponent{}
export default class Father extends React.Component{
    render=()=> <Index callback={()=>{}}   />
}
```
2. PureComponent的父组件是函数组件的情况 绑定函数要用useCallback或者useMemo处理 因为函数组件每一次执行 如果不处理 还会声明一个新的函数 
```javascript
class Index extends React.PureComponent{}
export default function (){
    const callback = function handerCallback(){} /* 每一次函数组件执行重新声明一个新的callback，PureComponent浅比较会认为不想等，促使组件更新  */
    return <Index callback={callback}  />
}
```
PureComponent对比同样会失效
综上可以用useCallback或者useMemo解决 首选useCallback 这个hooks初衷就是为了解决这种情况
```javascript
export default function (){
    const callback = React.useCallback(function handerCallback(){},[])
    return <Index callback={callback}  />
}
```
useCallback接受两个参数
第一个参数就是需要缓存的函数
第二个参数为deps deps中依赖项改变返回新的函数
如上处理之后就能从根本上解决PureComponent失效问题

3. shouldComponentUpdate  
   shouldComponentUpdate提供给使用者一种更灵活配置的自定义渲染方案 可以自己决定是否更新当前组件
   shouldComponentUpdate可以根据传入的新的props和state 或者newContext来确定是否更新组件
   有一种情况就是如果子组件的props是引用数据类型 不能直观比较是否相等  
   immutable.js 可以解决此问题 immutable.js不可变的状态 对Immutable对象的任何修改或添加删除操作都会返回一个新的Immutable对象 鉴于这个功能 可以把需要对比的props或者state数据变成Immutable对象 通过对比Immutable是否相等 来证明状态是否改变ß 从而确定是否更新组件

4. React.memo
   > React.memo(Component, compare)

   React.memo可以作为一种容器化的控制渲染方案 可以对比props变化 来决定是否渲染组件
   React.memo接受两个参数
   第一个参数Component原始组件本身
   第二个参数compare是一个函数 可以根据一次更新中props是否相同决定原始组件是否重新渲染
   React.memo的几个特点
   - 第二个参数返回true组件不渲染 返回false组件重新渲染 和shouldComponentUpdate相反
   - 第二个参数compare不存在时 会用浅比较原则处理props 相当于仅比较props版本的PureComponent
   - memo同样适合类组件和函数组件
   被memo包裹的组件 element会被打成REACT_MEMO_TYPE类型的element标签 在element变成fiber的时候 fiber会被标记成MemoComponent的类型
   > react/src/ReactMemo.js
   ```javascript
   function memo(type,compare){
   const elementType = {
        $$typeof: REACT_MEMO_TYPE, 
        type,  // 我们的组件
        compare: compare === undefined ? null : compare,  //第二个参数，一个函数用于判断prop，控制更新方向。
    };
    return elementType
    }
   ```
   > react-reconciler/src/ReactFiber.js
   ```javascript
   case REACT_MEMO_TYPE:
   fiberTag = MemoComponent;
   ```
   对于MemoComponent React内部处理的主要逻辑
   > react-reconciler/src/ReactFiberBeginWork.js
   ```javascript
   function updateMemoComponent(){
        if (updateExpirationTime < renderExpirationTime) {
            let compare = Component.compare;
            compare = compare !== null ? compare : shallowEqual //如果 memo 有第二个参数，则用二个参数判定，没有则浅比较props是否相等。
            if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
                return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime); //已经完成工作停止向下调和节点。
            }
        }
        // 返回将要更新组件,memo包装的组件对应的fiber，继续向下调和更新。
    }
   ```
   - 通过memo第二个参数 判断是否执行更新 如果没有第二个参数 则以浅比较props为diff规则 如果相等 当前fiber完成工作 停止向下调和节点 所以被包裹的组件不更新
   - memo可以理解为包了一层的高阶组件 他的阻断更新机制 是通过控制下一级children 也就是memo包装的组件 是否继续调和和渲染 来达到目的
5. 打破渲染限制
   - forceUpdate  
   类组件更新如果调用的是forceUpdate而不是setState 会跳过PureComponent的浅比较和shouldComponentUpdate  
   其原理是组件中调用forceUpdate时 全局会开启一个hasForceUpdate的开关  
   当组件更新的时候 检查这个开关是否打开 如果打开就直接跳过  
   - context穿透  
   上述的几种方式都不能阻止context的改变带来的渲染穿透

### 对于render的思考  

- 有没有必要在乎组件不必要渲染  
  正常情况下 无须过分在乎React没有必要的渲染 执行render不等于真正的浏览器渲染视图  
  render阶段执行是在js当中 js运行代码远快于浏览器的Rendering和Paining  
  更何况React还提供了diff算法等优化手段去复用真实DOM  
  
- 什么时候需要注意渲染节流  
  1. 数据可视化的模块组件展示了大量的数据 这种情况一次更新伴随着大量的diff 数据量越大也就越耗费性能 对于这种组件有必要采取memo shouldComponentUpdate等方案控制自身组件渲染  
  2. 含有大量表单的页面 一般会采用受控组件的模式去管理表单数据层 表单数据层完全托管于props或者state 而且往往需要频繁的改变数据层 很有可能让整个页面组件高频率render  
  3. 越靠近APP root根组件 越值得注意 根组件渲染会波及到整个组件树重新render 子组件render 一是浪费性能 二是可能执行useEffect componentWillReceiveProps等钩子 造成意想不到的情况发生  

- 一些开发中的细节  
  1. 开发过程中对于大量数据展示的模块 有必要用shouldComponentUpdate PureComponent来优化性能  
  2. 对于表单控件 最好单独抽离组件 独自管理自己的数据层 可以让state改变波及的范围更小  
  3. 配合immutable.js 更精致化渲染  
  4. 组件颗粒化 配合memo等api 可以制定私有化的渲染控件

### 问答
问：详细介绍下useMemo
答：
- useMemo用法
  > const cacheSomething = useMemo(create, deps)
  - create：第一个参数为一个函数 函数的返回值最为缓存值
  - deps：第二个参数为一个数组 存放当前useMemo的依赖项 在函数组件下一次执行的时候 会对比deps依赖项里面的状态是否有改变 如果有改变重洗执行create 得到新的缓存值
  - cacheSomething: 返回值 执行create的返回值 如果deps中有依赖项改变 返回的重洗执行create产生的值 否则取上一次缓存值
- useMemo原理
  useMemo会记录上一次执行create的返回值 并把它绑定在函数组件对应的fiber对象上 只要组件不销毁 缓存值就一直存在 但是deps中如果有一项改变 就会重新执行create 返回值作为新的值记录到fiber对象上
- useMemo应用场景
  - 可以缓存element对象 从而达到按条件渲染组件 优化性能的作用
  - 如果组件中不期望每次render都重新计算一些值 可以利用useMemo把它缓存起来
  - 可以把函数和属性缓存起来 作为PureComponent的绑定方法 或者配合其他的Hooks一起使用
  
问：useCallback和useMemo有什么区别  
答：useCallback第一个参数就是缓存的内容 useMemo需要执行第一个函数 返回值为缓存的内容
比起useCallback useMemo更像是缓存了一段逻辑 或者说执行这段逻辑获取的结果
useCallback也可以用来缓存element
