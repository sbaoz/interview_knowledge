# 原理-调度和时间片

### 何为异步调度  
- 为什么采用异步调度  
  GUI渲染线程和JS引擎线程是互斥的 在执行js的时候 会阻塞浏览器的渲染绘制 给用户直观的感受就是卡顿 V15版本的React面临如上的问题 对于大型的React应用 会存在一次更新 递归遍历大量的虚拟DOM 造成占用js线程 使得浏览器没有时间去做一些渲染 伴随项目越来越大 就会越来越卡  
  Vue框架有template模板收集依赖的过程 构建响应式 使得一次更新中 Vue能迅速响应 找到需要更新的范围 然后以组件粒度更新 渲染视图 但是在React中 一次更新无法知道此次更新的范围 所有React需要从根节点开始diff 查找不同 更新这些不同  
  为了解决更新过程造成的浏览器绘制阻塞 React把更新任务的执行控制交给浏览器 在绘制任务空闲时 执行更新任务 解决卡顿问题 调度就是具体的实现方式  

- 时间分片  
  浏览器每次执行一次事件循环都会做如下事情  
  处理事件 执行js 调用requestAnimation 布局Layout 绘制Paint  
  在执行后 如果没有其他事件 浏览器就会进入休息时间 那么有一些不是特别紧急的React更新就可以执行了  

  如何知道浏览器有空闲时间？  
  requestIdleCallback是谷歌浏览器提供的一个api 在浏览器有空余时间时 浏览器就会调用requestIdleCallback的回调  
  ```javascript
  requestIdleCallback(callback,{ timeout })
  ```
  callback: 浏览器空余时间执行回调函数  
  timeout: 如果浏览器长时间没有空闲 那么回调就不会执行 为了解决这个问题 可以通过这个参数指定一个超时时间  
  
  React为了防止requestIdleCallback中的任务由于浏览器没有空闲时间而卡死 设置了5个优先级  
  - Immediate -1 需要立刻执行  
  - UserBlocking 250ms 超时时间250ms 一般指的是用户交互  
  - Normal 5000ms 超时时间5s 不需要直观立即变化的任务 比如网络请求  
  - Low 10000ms 超时时间10s 肯定要执行的任务 但是可以放在最后处理  
  - Idle 一些没有必要的任务 可能不会执行  
  
  React的异步更新任务就是通过类似requestIdleCallback去向浏览器做一帧一帧请求 等到浏览器有空余时间 去执行React的异步更新任务 保证页面的流畅  

- 模拟requestIdleCallback  
  requestIdleCallback目前只有谷歌浏览器支持 为了兼容每个浏览器 React需要自己实现一个requestIdleCallback要具备2个条件  
  1. 可以主动让出主线程 让浏览器去渲染视图  
  2. 一次事件循环只执行一次 因为执行一次以后 还会请求下一次的时间片  
  能够满足上述条件的只有宏任务 宏任务是在下次事件循环中执行 不会阻塞浏览器更新 而且浏览器一次只会执行一个宏任务  
  满足两种情况的宏任务  
  - setTimeout(fn, 0)  
    setTimeout(fn, 0)可以满足创建宏任务 让出主线程 但是递归执行setTimeout(fn, 0)时 间隔时间会变成4ms左右 而不是1ms 所以React没有选择setTimeout(fn, 0)  
  - MessageChannel  
    为了让视图流畅的运行 可以按照人类能感知到最低限度每秒60帧的频率划分时间片 这样每个时间片就是16ms 也就是16ms要完成如上js执行 浏览器绘制等操作 上述setTimeout带来的浪费就有4ms 所以React采用新的方式去实现 那就是MessageChannel  
    MessageChannel接口允许开发者创建一个新的消息通道 并通过它的两个MessagePort属性发送数据  
    - MessageChannel.port1只读返回channel的port1  
    - MessageChannel.port2只读返回channel的port2  
    ```javascript
      let scheduledHostCallback = null 
      /* 建立一个消息通道 */
      var channel = new MessageChannel();
      /* 建立一个port发送消息 */
      var port = channel.port2;

      channel.port1.onmessage = function(){
          /* 执行任务 */
          scheduledHostCallback() 
          /* 执行完毕，清空任务 */
          scheduledHostCallback = null
      };
      /* 向浏览器请求执行更新任务 */
      requestHostCallback = function (callback) {
        scheduledHostCallback = callback;
        if (!isMessageLoopRunning) {
          isMessageLoopRunning = true;
          port.postMessage(null);
        }
      };
    ```
    - 在一次更新中 React会调用requestHostCallback 把更新任务赋值给scheduleHostCallback 然后port2向port1发起postMessage消息通知  
    - port1会通过onmessage 接受来自post2消息 然后执行更新任务scheduleHostCallback 然后置空scheduleHostCallback 借此达到异步执行目的