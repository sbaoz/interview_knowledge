# 原理-调度和时间片

### 何为异步调度  
- 为什么采用异步调度  
  GUI渲染线程和JS引擎线程是互斥的 在执行js的时候 会阻塞浏览器的渲染绘制 给用户直观的感受就是卡顿 V15版本的React面临如上的问题 对于大型的React应用 会存在一次更新 递归遍历大量的虚拟DOM 造成占用js线程 使得浏览器没有时间去做一些渲染 伴随项目越来越大 就会越来越卡  
  Vue框架有template模板收集依赖的过程 构建响应式 使得一次更新中 Vue能迅速响应 找到需要更新的范围 然后以组件粒度更新 渲染视图 但是在React中 一次更新无法知道此次更新的范围 所有React需要从根节点开始diff 查找不同 更新这些不同  
  为了解决更新过程造成的浏览器绘制阻塞 React把更新任务的执行控制交给浏览器 在绘制任务空闲时 执行更新任务 解决卡顿问题 调度就是具体的实现方式  

- 时间分片  
  浏览器每次执行一次事件循环都会做如下事情  
  处理事件 执行js 调用requestAnimation 布局Layout 绘制Paint  
  在执行后 如果没有其他事件 浏览器就会进入休息时间 那么有一些不是特别紧急的React更新就可以执行了  

  如何知道浏览器有空闲时间？  
  requestIdleCallback是谷歌浏览器提供的一个api 在浏览器有空余时间时 浏览器就会调用requestIdleCallback的回调  
  ```javascript
  requestIdleCallback(callback,{ timeout })
  ```
  callback: 浏览器空余时间执行回调函数  
  timeout: 如果浏览器长时间没有空闲 那么回调就不会执行 为了解决这个问题 可以通过这个参数指定一个超时时间  
  
