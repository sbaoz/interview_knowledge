# ref

### ref对象创建  
- 什么是ref对象  
用createRef或者useRef创建出来的对象  
```javascript
{
    current: null // current指向ref对象获取的实际内容 可以是dom元素 组件实例 或者其他
}
```
- 类组件React.createRef  
> react/src/ReactCreateRef.js
```javascript
export function createRef() {
  const refObject = {
    current: null,
  }
  return refObject;
}
```
不要在函数组件中使用createRef 否则会造成ref对象内容丢失等情况  
- 函数组件React.useRef
useRef底层逻辑和createRef类似 只是ref保存的位置不同  
类组件有一个实例instance能够维护ref 但是函数组件每次更新 所有变量都会重新声明  
useRef不能像createRef一样把ref直接暴露出去 ref就会随着函数组件执行被重置  
为了解决这个问题 hooks和函数组件对应的fiber对象建立关联 将useRef产生的ref对象挂到函数组件对应的fiber对象上 函数组件每次执行 只要组件不被销毁 对应的fiber对象一直存在 ref信息就会被保存下来  

### React对ref属性的处理  
React对标签里面的ref属性的处理逻辑是多样化的  

- ref属性是一个字符串
```javascript
class Children extends Component{  
    render=()=><div>hello,world</div>
}

export default class Index extends React.Component{
    componentDidMount(){
       console.log(this.refs)
    }
    render=()=> <div>
        <div ref="currentDom">字符串模式获取元素或组件</div>
        <Children ref="currentComInstance" />
    </div>
}
```
用一个字符串ref标记一个DOM元素 一个类组件（函数组件没有实例 一般不能被ref标记）  
React底层逻辑会判断类型  
如果是DOM元素 会把真实DOM绑定在this.refs属性上  
如果是类组件 会把组件的实例绑定在this.refs属性上  

- ref属性是一个函数  
```javascript
class Children extends React.Component{  
    render=()=><div>hello,world</div>
}

export default class Index extends React.Component{
    currentDom = null
    currentComponentInstance = null
    componentDidMount(){
        console.log(this.currentDom)
        console.log(this.currentComponentInstance)
    }
    render=()=> <div>
        <div ref={(node)=> this.currentDom = node }>Ref模式获取元素或组件</div>
        <Children ref={(node) => this.currentComponentInstance = node  } />
    </div>
}
```
当用一个函数来标记ref的时候 将作为callback形式 等到真实DOM创建阶段执行callback 获取的DOM元素或组件实例 将以回调函数第一个参数形式传入 所以可以像上述代码片段中用组件实例下的属性currentDom和currentComponentInstance来接收真实DOM和组件实例  

- ref属性是一个ref对象  
```javascript
class Children extends React.Component{  
    render=()=><div>hello,world</div>
}

export default class Index extends React.Component{
    currentDom = React.createRef(null)
    currentComponentInstance = React.createRef(null)
    componentDidMount(){
        console.log(this.currentDom)
        console.log(this.currentComponentInstance)
    }
    render=()=> <div>
         <div ref={ this.currentDom }>Ref对象模式获取元素或组件</div>
        <Children ref={ this.currentComponentInstance } />
   </div>
}
```
在ref对象的current属性下访问  

### ref的高阶用法  

- forwardRef转发ref  
  forwardRef的初衷就是解决ref不能跨层级捕获和传递的问题 forwardRef接受了父级元素标记的ref信息 并把它转发下去 使得子组件可以通过props来接受到上一层级或者是更上层级的ref  
  
1. 跨层级获取
2. 合并转发ref
3. 高阶组件转发

