# 优化-渲渲染调优  

### 懒加载和异步渲染  

- 异步渲染  
  Suspense是React提出的一种同步的代码来实现异步操作的方案 Suspense让组件等待异步操作 异步请求结束后再进行组件的渲染  
  目前这个功能还在试验阶段  
  - Suspense的用法  
    Suspense是组件 有一个fallback属性 用来代替当Suspense处于loading状态下渲染的内容  
    Suspense的children就是异步组件 多个异步组件可以用Suspense嵌套使用  

- 动态加载（懒加载）  
  Suspense配合React.lazy可以实现动态加载功能  
  React.lazy接受一个函数 这个函数需要动态调用import() 必须返回一个Promise 改Promise需要resolve一个default export的React组件  
  用React.lazy动态引入的组件 配合Suspense实现动态加载组件效果 这样利于代码分割 不会让初始化的时候加载大量的文件  
  
  - React.lazy和Suspense实现动态加载原理  
    Suspense原理  
    Suspense在执行内部可以通过try{}catch{}方式捕获异常 这个异常通常是一个Promise  
    可以在这个Promise中进行数据请求 Suspense内部会处理这个Promise  
    Promise结束后 Suspense会再一次重新render把数据渲染出来 达到异步渲染的效果
    lazy原理  
    lazy内部模拟一个PromiseA规范场景 用Promise模拟了一个请求数据的过程 但是请求的结果不是数据 而是一个动态的组件  
    lazy利用Suspense接受Promise 执行Promise 然后再渲染这个特性做到了动态加载
    > react/src/ReactLazy.js
    ```javascript
    function lazy(ctor){
        return {
            $$typeof: REACT_LAZY_TYPE,
            _payload:{
                _status: -1,  //初始化状态
                _result: ctor,
            },
            _init:function(payload){
                if(payload._status===-1){ /* 第一次执行会走这里  */
                    const ctor = payload._result;
                    const thenable = ctor();
                    payload._status = Pending;
                    payload._result = thenable;
                    thenable.then((moduleObject)=>{
                        const defaultExport = moduleObject.default;
                        resolved._status = Resolved; // 1 成功状态
                        resolved._result = defaultExport;/* defaultExport 为我们动态加载的组件本身  */ 
                    })
                }
                if(payload._status === Resolved){ // 成功状态
                    return payload._result;
                }
                else {  //第一次会抛出Promise异常给Suspense
                    throw payload._result; 
                }
            }
        }
    }
    ```
    React.lazy包裹的组件会标记REACT_LAZY_TYPE类型的element 在调和阶段会变成LazyComponent类型的fiber React对LazyComponent会有单独的处理逻辑：  
    - 第一次渲染首先会执行init方法 里面会执行lazy的第一个函数 得到一个Promise 绑定Promise.then成功回调 回调里得到将要渲染组件defaultExport 这里要注意的是 如上面的函数当第二个if判断的时候 因为此时状态不是Resolved 所以会走else 抛出异常Promise 抛出异常会让当前渲染终止  
    - 这个异常Promise会被Suspense捕获到 Suspense会处理Promise Promise执行成功回调得到defaultExport 然后Suspense发起第二次渲染 第二次init方法以及是Resolved成功状态 那么直接返回result也就是真正渲染的组件  

### 渲染错误边界

React组件渲染过程如果有一个环节出现问题 就会导致整个组件渲染失败 那么整个组件的UI层都会显示不出来 而且越靠近APP应用的根组件 渲染过程中出现问题造成的影响就越大  

为了防止渲染异常情况 React增加了componentDidCatch和static getDerivedStateFromError()两个额外的生命周期 去挽救由于渲染阶段出现问题造成UI界面无法显示的情况  

- componentDidCatch
  componentDidCatch可以捕获异常 接受两个参数  
  1. error：抛出的错误  
  2. info：带有componentStack key的对象 其中包含有关组件引发错误的栈信息  
  componentDidCatch中可以再次出发setState 来降级UI渲染    
  componentDidCatch会在commit阶段调用 因此允许执行副作用  
  可以在componentDidCatch中调用setState促使组件渲染 并做一些错误拦截功能 监控组件 上报错误日志
- static getDerivedStateFromError
  React更期望用getDerivedStateFromError代替componentDidCatch用于处理渲染异常的情况  
  getDerivedStateFromError是静态方法 内部不能调用setState  getDerivedStateFromError返回的值可以合并到state作为渲染使用

### 从diff children看key的合理使用
合理的使用key有助于精准的找到用于新节点复用的老节点  

- diff children流程
  1. 遍历新children 复用oldfiber
  > react-reconciler/src/ReactChildFiber.js
  ```javascript
  function reconcileChildrenArray(){
    /* 第一步  */
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {  
        if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = null;
        } else {
            nextOldFiber = oldFiber.sibling;
        }
        const newFiber = updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime,);
        if (newFiber === null) { break }
        // ..一些其他逻辑
        }  
        if (shouldTrackSideEffects) {  // shouldTrackSideEffects 为更新流程。
            if (oldFiber && newFiber.alternate === null) { /* 找到了与新节点对应的fiber，但是不能复用，那么直接删除老节点 */
                deleteChild(returnFiber, oldFiber);
            }
        }
    }
  ```
  - 第一步对于React.createElement产生新的child组成的数组 首先会遍历数组 因为fiber对于同一级兄弟节点是用sibling指针指向 所以在遍历children时 sibling指针同时移动 找到与child对应的oldFiber
  - 然后通过调用updateSlot updateSlot内部会判断当前的tag和key是否匹配 如果匹配复用老fiber形成新的fiber 如果不匹配 返回null 此时newFiber等于null
  - 如果是出于更新流程 找到与新节点对应的老fiber 但是不能复用 alternate===null 那么会删除老fiber
  2. 统一删除oldFiber  
  ```javascript
  if (newIdx === newChildren.length) {
    deleteRemainingChildren(returnFiber, oldFiber);
    return resultingFirstChild;
  }
  ```
  - 第二步适用于以下情况 当第一步结束 newIdx === newChildren.length 此时证明所有newChild已经全部被遍历完 那么剩下没有遍历的oldFiber也就没有用了 那么调用deleteRemainingChildren统一删除oldFiber  
  情况一：节点删除  
  oldChild: A B C D  
  newChild: A B  
  A、B经过第一步遍历复制完成 那么newChild遍历完成 此时C、D已经没有用了 那么统一删除C、D  
  3. 统一创建newFiber  
  ```javascript
  if(oldFiber === null){
   for (; newIdx < newChildren.length; newIdx++) {
       const newFiber = createChild(returnFiber,newChildren[newIdx],expirationTime,)
       // ...
     }
  }
  ```
  - 第三步适合如下的情况 当经历过第一步 oldFiber为null 证明oldFiber复用完毕 那么如果还有新的children 说明都是新的元素 只需要调用createChild创建新的fiber  
  情况二：节点增加  
  oldChild: A B  
  newChild: A B C D  
  A B经过第一步遍历复制完 oldFiber没有可以复用的了 那么直接创建C D  
  4. 针对发生移动和更复杂的情况  
  ```javascript
  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
  for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = updateFromMap(existingChildren,returnFiber)
      /* 从mapRemainingChildren删掉已经复用oldFiber */
  }
  ```
  - mapRemainingChildren返回一个map map里存放剩余的老fiber和对应的key的映射关系  
  - 接下来遍历剩下没有处理的Children 通过updateFromMap 判断mapRemainingChildren中有没有可以复用的oldFiber 如果有 则复用 如果没有 就创建一个newFiber
  - 复用的oldFiber会从mapRemainingChildren删除
  情况三：节点位置改变  
  oldChild：A B C D  
  newChild: A B D C  
  如上A B在第一步被有效复用 第二步和第三步不符合 直接进行第四步 C D被完全复用 existingChildren为空  
  5. 删除剩余没有复用的oldFiber  
  ```javascript
  if (shouldTrackSideEffects) {
    /* 移除没有复用到的oldFiber */
    existingChildren.forEach(child => deleteChild(returnFiber, child));
  }
  ```
  - 最后一步 对于没有复用的oldFiber 统一删除处理  
  情况四：复杂情况(删除+新增+移动)  
  oldChild: A B C D  
  newChild: A E D B  
  首先A节点 在第一步被复用 接下来直接到第四步 遍历newChild E被创建 D B从existingChildren中被复用 existingChildren还剩一个C 在第五步会删除C 完成整个流程  
- 关于diffChild思考和key的使用  
  1. React diffChild时间复杂度O(n^3)优化到O(n)  
  2. React key最好选择唯一性的id 如上流程 如果选择index为key 如果元素发生移动 那么从移动节点开始 接下来的fiber都不能得到合理的复用 index拼接其他字段也会造成相同的效果  
