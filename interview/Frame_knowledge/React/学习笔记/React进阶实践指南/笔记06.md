# 生命周期
- render阶段(调和)  
React在调和阶段会深度遍历fiber树 目的是发现不同(diff)  
不同的地方就是需要更新的地方 对于变化的组件 就会执行render函数
- commit阶段  
在一次调和过程完毕之后 进入commit阶段 创建修改真实的DOM节点  
  
- 重要概念  
1. instance：类组件对应实例  
2. workInProgress树：内存中正在构建的fiber树 反应了要刷新到屏幕的未来状态  
3. current树：当前屏幕上显示内容对应的fiber树  
4. Component：就是项目中的class组件  
5. nextProps：作为组件在一次更新中新的props  
6. renderExpirationTime：作为下一次渲染的过期时间  

### 类组件的生命周期
- 组件初始化  
    - render阶段  
        1. constructor
        2. getDerivedFromProps/componentWillMount
        3. render
    - commit阶段  
        4. componentDidMount  
    
> react-reconciler/src/ReactFiberBeginWork.js
```javascript
/* workloop React 处理类组件的主要功能方法 */
function updateClassComponent(){
    let shouldUpdate
    const instance = workInProgress.stateNode // stateNode 是 fiber 指向 类组件实例的指针。
     if (instance === null) { // instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程
        constructClassInstance(workInProgress, Component, nextProps); // 组件实例将在这个方法中被new。
        mountClassInstance(  workInProgress,Component, nextProps,renderExpirationTime ); //初始化挂载组件流程
        shouldUpdate = true; // shouldUpdate 标识用来证明 组件是否需要更新。
     }else{  
        shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderExpirationTime) // 更新组件流程
     }
     if(shouldUpdate){
         nextChildren = instance.render(); /* 执行render函数 ，得到子节点 */
        reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime) /* 继续调和子节点 */
     }
}
```

- 组件更新  
    - render阶段  
      1. getDerivedStateFromProps/componentWillReceiveProps  
      2. shouldComponentUpdate  
      3. componentWillUpdate  
      4. render  
    - commit阶段  
      5. getSnapshotBeforeUpdate  
      6. componentDidUpdate  

> react-reconciler/src/ReactFiberClassComponent.js
```javascript
function updateClassInstance(current,workInProgress,ctor,newProps,renderExpirationTime){
    const instance = workInProgress.stateNode; // 类组件实例
    const hasNewLifecycles =  typeof ctor.getDerivedStateFromProps === 'function'  // 判断是否具有 getDerivedStateFromProps 生命周期
    if(!hasNewLifecycles && typeof instance.componentWillReceiveProps === 'function' ){
         if (oldProps !== newProps || oldContext !== nextContext) {     // 浅比较 props 不相等
            instance.componentWillReceiveProps(newProps, nextContext);  // 执行生命周期 componentWillReceiveProps 
         }
    }
    let newState = (instance.state = oldState);
    if (typeof getDerivedStateFromProps === 'function') {
        ctor.getDerivedStateFromProps(nextProps,prevState)  /* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */
        newState = workInProgress.memoizedState;
    }   
    let shouldUpdate = true
    if(typeof instance.shouldComponentUpdate === 'function' ){ /* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */
        shouldUpdate = instance.shouldComponentUpdate(newProps,newState,nextContext,);
    }
    if(shouldUpdate){
        if (typeof instance.componentWillUpdate === 'function') {
            instance.componentWillUpdate(); /* 执行生命周期 componentWillUpdate  */
        }
    }
    return shouldUpdate
}
```
> react-reconciler/src/ReactFiberCommitWork.js
```javascript
function commitBeforeMutationLifeCycles(current,finishedWork){
     switch (finishedWork.tag) {
          case ClassComponent:{
               const snapshot = instance.getSnapshotBeforeUpdate(prevProps,prevState) /* 执行生命周期 getSnapshotBeforeUpdate   */
                instance.__reactInternalSnapshotBeforeUpdate = snapshot; /* 返回值将作为 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 生命周期  */
          }
     }
}
```

- 组件销毁  
    - commit阶段  
      1. componentWillUnmount

> react-reconciler/src/ReactFiberCommitWork.js

```javascript
function callComponentWillUnmountWithTimer(){
    instance.componentWillUnmount();
}
```

### React各阶段生命周期能做些什么  
- constructor  
在类组件创建实例时调用 而且只在初始化的时候执行一次 可以在constructor做一些初始化的工作
1. 初始化state 比如截取路由中的参数赋值给state  
2. 绑定this 节流防抖等  
3. 对类组件进行一些必要的生命周期的劫持 渲染劫持
- getDerivedStateFromProps  
1. 代替componentWillMount和componentWillReceiveProps  
2. 组件初始化或者更新时 将props映射到state  
3. 返回值与state合并 可以作为shouldComponentUpdate第二个参数nextState  
- UNSAFE_componentWillMount  
1. 在render之前调用 因此在此方法中同步调用setState不会触发额外渲染  
2. 通常建议使用constructor来初始化  
3. 避免在此方法中引入任何副作用或订阅  
4. 过时的生命周期方法 未来将废弃  
- UNSAFE_componentWillReceiveProps  
1. 该生命周期执行驱动是因为父组件更新带来的props修改 并接受更新后的props  
2. 只要父组件触发render函数 那么props就会被重新创建 无论props的内容是否改变 都会触发该生命周期  
3. 可以用来监听父组件是否执行render  
4. 组件可以根据props的改变来决定是否更新state  
5. 可以在异步请求后改变state 但是不推荐 因为在没有优化的前提下子组件会重复执行render  
6. 过时的生命周期方法 未来将废弃  
- UNSAFE_componentWillUpdate  
1. 触发时的DOM还没有更新 可以做一些获取DOM的操作 已经有getSnapshotBeforeUpdate来代替  
2. 过时的生命周期方法 未来将废弃  
- render  
1. jsx的各个元素被React.createElement创建成React element对象的形式  
2. 一次render的过程 就是创建React element对象的过程  
3. 可以做一些createElement创建元素, cloneElement克隆元素，React.children遍历children的操作  
- getSnapshotBeforeUpdate  
1. 该生命周期是在 commit 阶段的before Mutation ( DOM 修改前)，此时 DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM 此时是获取 DOM 信息的最佳时期  
2. getSnapshotBeforeUpdate 将返回一个值作为一个snapShot(快照)，传递给 componentDidUpdate作为第三个参数  
3. 配合componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate 保存一次更新前的信息  
- componentDidUpdate  
1. componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState ，一定要加以限制，否则会引起无限循环。  
2. 接受 getSnapshotBeforeUpdate 保存的快照信息  
- componentDidMount  
1. 可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器  
2. 对于初始化向服务器请求数据，渲染视图  
- shouldComponentUpdate  
1. 一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件  
2. 需要重点关注的是第二个参数 newState ，如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供 shouldComponentUpdate 使用  
- componentWillUnmount  
1. 做一些收尾工作，比如清除一些可能造成内存泄漏的定时器，延时器，或者是一些事件监听器
  

### 函数组件生命周期替代方案  
React hooks提供了api 弥补了函数组件没有生命周期的缺陷  其原理主要是运用了hooks里面的useEffect和useLayoutEffect  

- useEffect和useLayoutEffect  
1. useEffect  
```javascript
useEffect(() => {
    return destory
}, [dep])
```
useEffect第一个参数callback 返回的destroy作为下一次callback执行之前调用 用于清除上一次callback产生的副作用  
第二个参数作为依赖项 是一个数组 可以有多个依赖项 依赖项改变 执行上一次callback返回的destroy和执行新的Effect第一个参数callback  
对于useEffect的callback执行 React采用异步调用 等到主线程任务完成 DOM更新 js执行完成 视图绘制完成后才执行 所以useEffect回调函数不会阻塞浏览器绘制视图  
2. useLayoutEffect  
useLayoutEffect和useEffect不同的地方是采用了同步执行  
useLayoutEffect执行是在DOM绘制之前 这样可以方便修改DOM 浏览器只会绘制一次 如果修改DOM布局放在useEffect里面 会导致浏览器再次回流和重绘 视图上可能会造成闪现的效果  
useLayoutEffect的callback中代码执行会阻塞浏览器绘制  
> 一句话概括如何选择 useEffect 和 useLayoutEffect ：修改 DOM ，改变布局就用 useLayoutEffect ，其他情况就用 useEffect

- componentDidMount替代方案  
```javascript
React.useEffect(()=>{
    /* 请求数据 ， 事件监听 ， 操纵dom */
},[])  /* 切记 dep = [] */
```
dep = [] ，这样当前 effect 没有任何依赖项，也就只有初始化执行一次  

- componentWillUnmount替代方案  
```javascript
 React.useEffect(()=>{
        /* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */
        return function componentWillUnmount(){
            /* 解除事件监听器 ，清除定时器，延时器 */
        }
},[])/* 切记 dep = [] */
```
在 componentDidMount 的前提下，useEffect 第一个函数的返回函数，可以作为 componentWillUnmount 使用  

- componentWillReceiveProps替代方案  
```javascript
React.useEffect(()=>{
    console.log('props变化：componentWillReceiveProps')
},[ props ])
```
说 useEffect 代替 componentWillReceiveProps 着实有点牵强  
1. 首先因为二者的执行阶段根本不同，一个是在render阶段，一个是在commit阶段  
2. 其次 useEffect 会初始化执行一次，但是 componentWillReceiveProps 只有组件更新 props 变化的时候才会执行  

- componentDidUpdate替代方案  
```javascript
React.useEffect(()=>{
    console.log('componentDidUpdate');     
}) /* 没有 dep 依赖项 */
```
1. useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect 是异步执行，componentDidUpdate 是同步执行 ，但都是在 commit 阶段  
2. useEffect 会默认执行一次，而 componentDidUpdate 只有在组件更新完成后执行  

### 问答  
问：当props不变的前提下 PureComponent组件能否阻止componentWillReceiveProps执行？  
答：不能 componentWillReceiveProps的执行和纯组件没有关系 纯组件是在componentWillReceiveProps执行之后浅比较props是否发生变化 所有不会阻止该生命周期的执行  

问：UNSAFE_componentWillXXX为什么UNSAFE？
答：  
React V16.3给componentWillMount ，componentWillReceiveProps ， componentWillUpdate 三个生命周期加上了不安全的标识符 UNSAFE，  
Fiber架构下 reconciler会进行多次 reconciler过程又会调用多次之前的willXXX 造成语意不明  
多次调用willXXX会导致一些性能安全、数据错乱等问题  

问：setEffect 回调函数 和 componentDidMount / componentDidUpdate 执行时机有什么区别？  
答：  
useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount / componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。  
在时机上 ，componentDidMount / componentDidUpdate 和 useLayoutEffect 更类似  

