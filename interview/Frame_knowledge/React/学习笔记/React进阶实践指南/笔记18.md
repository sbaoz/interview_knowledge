# 原理-Hooks  
Hooks出现的原因  
- 让函数组件也能做类组件的事 有自己的状态 可以处理一些副作用 能获取ref 能做数据缓存  
- 解决逻辑复用难的问题  
- 拥抱函数式编程  

### hooks与fiber(workInProgress)   
类组件的状态比如state context props本质上是存在类组件对应的fiber上 包括生命周期比如componentDidMount 也是以副作用effect形式存在的 那么hooks既然赋予了函数组件如上功能 所以hook本质是离不开函数组件对应的fiber的 hooks可以作为函数组件本身和函数组件对应的fiber之间的沟通桥梁  
![hooks与fiber的关系](../images/hooks与fiber的关系.png)  
hooks对象本质上是主要以三种处理策略存在React中  
- ContextOnlyDispatcher 第一种形态是防止开发者在函数组件外部调用hooks 所以第一种就是抱错形态 只要开发者调用了这个形态下的hooks 就会抛出异常  
- HooksDispatcherOnMount 第二种形态是函数组件初始化mount 因为hooks是函数组件和对应fiber的桥梁 这个时候的作用就是建立这个桥梁 初次建立hooks与fiber之间的关系  
- HooksDispatchOnUpdate 第三种形态是函数组件的更新 既然与fiber之间的桥梁已经建立 那么组件更新就需要hooks去获取或者更新维护状态  
一个hooks对象  
```javascript
const HooksDispatcherOnMount = { /* 函数组件初始化用的 hooks */
    useState: mountState,
    useEffect: mountEffect,
    ...
}
const  HooksDispatcherOnUpdate ={/* 函数组件更新用的 hooks */
   useState:updateState,
   useEffect: updateEffect,
   ...
}
const ContextOnlyDispatcher = {  /* 当hooks不是函数内部调用的时候，调用这个hooks对象下的hooks，所以报错。 */
   useEffect: throwInvalidHookError,
   useState: throwInvalidHookError,
   ...
}
```
- 函数组件触发  
  所有函数组件的触发是在renderWithHooks方法中 在fiber调和过程中 遇到FunctionComponent类型的fiber 就会用updateFunctionComponent更新fiber 在updateFunctionComponent内部就会调用renderWithHooks  
  > react-reconciler/src/ReactFiberHooks.js
  ```javascript
  let currentlyRenderingFiber
  function renderWithHooks(current,workInProgress,Component,props){
        currentlyRenderingFiber = workInProgress;
        workInProgress.memoizedState = null; /* 每一次执行函数组件之前，先清空状态 （用于存放hooks列表）*/
        workInProgress.updateQueue = null;    /* 清空状态（用于存放effect list） */
        ReactCurrentDispatcher.current =  current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate /* 判断是初始化组件还是更新组件 */
        let children = Component(props, secondArg); /* 执行我们真正函数组件，所有的hooks将依次执行。 */
        ReactCurrentDispatcher.current = ContextOnlyDispatcher; /* 将hooks变成第一种，防止hooks在函数组件外部调用，调用直接报错。 */
    }
  ```
  workInProgress正在调和更新函数组件对应的fiber树  
  - 对于类组件fiber 用memorizedState保存state信息 对于函数组件fiber 用memorizedState保存hooks信息  
  - 对于函数组件fiber updateQueue存放每个useEffect/useLayoutEffect产生的副作用组成的链表 在commit阶段更新这些副作用  
  - 然后判断组件是初始化流程还是更新流程 如果初始化用HooksDispatchOnMount对象 如果更新用HooksDispatchOnUpdate对象 引用的React hooks都是从ReactCurrentDispatcher.current中的 React就是通过赋予current不同的hooks对象达到监控hooks是否在函数组件内部调用  
  - Component(props, secondArg)这个时候函数组件被真正的执行 里面每个hooks也将依次执行  
  - 每个hooks内部为什么能够读取当前fiber信息 因为currentlyRenderingFiber 函数组件初始化已经把当前fiber赋值给currentlyRenderingFiber 每个hooks内部读取的就是currentlyRenderingFiber的内容  

- hooks初始化-hooks如何建立和fiber的关系  
  hooks初始化流程使用的是mountState mountEffect等初始化节点的hooks将hooks和fiber建立起联系 每个hooks初始化都会执行mountWorkInProgressHook  
  > react-reconciler/src/ReactFiberHooks.js
  ```javascript
  function mountWorkInProgressHook() {
      const hook = {  memoizedState: null, baseState: null, baseQueue: null,queue: null, next: null,};
      if (workInProgressHook === null) {  // 只有一个 hooks
         currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
      } else {  // 有多个 hooks
         workInProgressHook = workInProgressHook.next = hook;
      }
      return workInProgressHook;
   }
  ```
  首先函数组件对应fiber用memorizedState保存hooks信息 每个hooks执行都会产生一个hooks对象 hooks对象中保存着当前hooks的信息 不同的hooks保存的形式不同 每个hooks通过next链表建立起关系  
  