# HOC  

### 高阶组件基本介绍-能解决什么问题  
HOC的根本作用就是解决大量的代码复用 逻辑复用问题  
- 对渲染的控制  
- 让props中混入一些需要的东西
- 不想改变组件 只是监控组件的内部状态 对组件做一些赋能

### 高阶组件基础概念
高阶组件是以组件作为参数 返回组件的函数 返回的组件把传进去的组件进行功能强化

### 两种不同的高阶组件  
常用的高阶组件有属性代理和反向继承两种

- 属性代理
  就是用组件包裹一层代理组件 在代理组件上可以做一些对原组件的强化操作
  这里注意属性代理返回的是一个新组件 被包裹的原始组件将在新的组件里被挂载
```javascript
function HOC(WrapComponent){
    return class Advance extends React.Component{
       state={
           name:'alien'
       }
       render(){
           return <WrapComponent  { ...this.props } { ...this.state }  />
       }
    }
}
```
优点：
1. 属性代理可以和业务组件低耦合 零耦合 对于条件渲染和props属性增强 只负责控制子组件渲染和传递额外的props就可以了 无需知道业务组件做了些什么 所有正向属性代理适合做一些开源项目的HOC
2. 同样适用于类组件和函数组件
3. 可以完全隔离业务组件的渲染 因为属性代理说白了就是一个新的组件 相比反向继承 可以完全控制业务组件是否渲染
4. 可以嵌套适用 多个HOC是可以嵌套使用的 而且一般不会限制包装HOC的先后顺序

缺点：
1. 一般无法直接获取原始组件的状态 需要ref获取组件实例
2. 无法直接继承静态属性 需要手动处理或者使用第三方库
3. 因为本质上市产生了一个新组件 所有需要配合forwardRef来转发ref

- 反向继承
  反向继承和属性代理有一定的区别 在于包装后的组件继承了原始组件本身 所以此时无需再去挂载业务组件
```javascript
class Index extends React.Component{
  render(){
    return <div> hello,world  </div>
  }
}
function HOC(Component){
    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */
        
    }
}
export default HOC(Index) 
```
优点：
1. 方便获取组件内部状态 比如state、props、生命周期、绑定的事件函数等
2. es6继承可以良好的继承静态属性 无需对静态属性和方法进行额外的处理

缺点：
1. 函数组件无法使用
2. 和被包装的组件耦合度搞 需要知道被包装的原始组件的内部状态具体做了什么
3. 如果多个反向继承HOC嵌套在一起 当前状态会覆盖上一个状态 这样带来的隐患是非常大的 比如多个componentDidMount 当前的componentDidMount会覆盖上一个componentDidMount 这样副作用串联起来 影响很大

### 高阶组件功能说明-如何编写高阶组件

- 强化props
  强化props就是在原始组件的props基础上 加入一些其他的props 强化原始组件功能 举个例子 为了让组件也可以获取到路由对象 进行路由跳转等操作 所有React Router提供了类似withRouter的HOC
  ```javascript
  function withRouter(Component) {
        const displayName = `withRouter(${Component.displayName || Component.name})`;
        const C = props => {
            /*  获取 */
            const { wrappedComponentRef, ...remainingProps } = props;
            return (
            <RouterContext.Consumer>
                {context => {
                return (
                    <Component
                    {...remainingProps} // 组件原始的props 
                    {...context}        // 存在路由对象的上下文，history  location 等 
                    ref={wrappedComponentRef}
                    />
                );
                }}
            </RouterContext.Consumer>
            );
        };

        C.displayName = displayName;
        C.WrappedComponent = Component;
        /* 继承静态属性 hoist-non-react-statics库 */
        return hoistStatics(C, Component);
    }
    export default withRouter
  ```
  流程分析：
  - 分离出props中wrappedComponentRef和remainingProps remainingProps是原始组件真正的props wrappedComponentRef用于转发ref
  - 用Context.Consumer上下文模式获取保存的路由信息 React Router中路由状态时通过context上下文保存传递的
  - 将路由对象和原始props传递给原始组件 所以可以在原始组件中获取history location等信息

- 控制渲染
  - 渲染劫持&&修改渲染树
    HOC反向继承模式 可以通过super.render()得到render之后的内容 利用这一点 可以做渲染劫持 甚至修改render之后的React element对象
  - 动态加载
    配合import实现组件的动态加载 实现代码分割 加入loading效果
- 组件赋能
  - ref获取实例
    属性代理可以通过ref获取组件实例 来获取组件的一些状态或手动触发一些事件 进一步强化组件 注意类组件才存在实例 函数组件不存在实例
  - 事件监控
    HOC不一定要对组件本身做些什么 也可以单纯增加一些事件监听 错误监控

### 高阶组件注意事项
- 谨慎修改原型链
  利用HOC修改原型链的时候 多个HOC同时修改会有功能失效的情况
- 不要在函数组件内部或类组件render函数中使用HOC
  每一次类组件触发render或者函数组件执行都会产生一个新的Wrap react diff会判定两次不是同一个组件 就会卸载老组件 重新挂载新组件 老组件内部的真实DOM节点都不会合理的复用 造成性能的浪费 原始组件也会被初始化多次
- ref的处理
  高阶组件是将所有props传递给被包装的组件 但对ref并不适用 ref不是一个prop 和key类似 React会专门处理 需要用forwardRef转发处理
- 注意多个HOC嵌套
  需要留意HOC的顺序 分析各个HOC之间是否有依赖关系
  类组件可以用装饰器模式对类组件进行包装
  包装顺序：越内层的HOC 离原始组件越近
  如果2个HOC之间有依赖 比如HOC1依赖HOC2 那么HOC1应该在HOC2的内部
  涉及到获取原始组件实例的HOC 要离原始组件最近
- 继承静态属性
  属性代理HOC本质上是返回一个新的组件 如果原来的组件绑定了一些静态属性方法 不处理的话 新的组件会丢失这些静态方法
  手动继承：必须准确知道应该拷贝哪些静态属性方法
  引入第三方库：hoist-non-react-statics
